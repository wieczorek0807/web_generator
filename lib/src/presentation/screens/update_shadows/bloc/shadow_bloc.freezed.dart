// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'shadow_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$ShadowEventTearOff {
  const _$ShadowEventTearOff();

  _InitialEvent initial() {
    return const _InitialEvent();
  }

  _UpdateOffsetY updateOffsetY(double value) {
    return _UpdateOffsetY(
      value,
    );
  }

  _UpdateOffsetX updateOffsetX(double value) {
    return _UpdateOffsetX(
      value,
    );
  }

  _UpdateBlur updateBlur(double value) {
    return _UpdateBlur(
      value,
    );
  }

  _UpdateRadius updateSpread(double value) {
    return _UpdateRadius(
      value,
    );
  }

  _UpdateColorR updateColorR(double value) {
    return _UpdateColorR(
      value,
    );
  }

  _UpdateColorG updateColorG(double value) {
    return _UpdateColorG(
      value,
    );
  }

  _UpdateColorB updateColorB(double value) {
    return _UpdateColorB(
      value,
    );
  }
}

/// @nodoc
const $ShadowEvent = _$ShadowEventTearOff();

/// @nodoc
mixin _$ShadowEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(double value) updateOffsetY,
    required TResult Function(double value) updateOffsetX,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(double value) updateColorR,
    required TResult Function(double value) updateColorG,
    required TResult Function(double value) updateColorB,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(double value)? updateOffsetY,
    TResult Function(double value)? updateOffsetX,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(double value)? updateColorR,
    TResult Function(double value)? updateColorG,
    TResult Function(double value)? updateColorB,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(double value)? updateOffsetY,
    TResult Function(double value)? updateOffsetX,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(double value)? updateColorR,
    TResult Function(double value)? updateColorG,
    TResult Function(double value)? updateColorB,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UpdateOffsetY value) updateOffsetY,
    required TResult Function(_UpdateOffsetX value) updateOffsetX,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateRadius value) updateSpread,
    required TResult Function(_UpdateColorR value) updateColorR,
    required TResult Function(_UpdateColorG value) updateColorG,
    required TResult Function(_UpdateColorB value) updateColorB,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UpdateOffsetY value)? updateOffsetY,
    TResult Function(_UpdateOffsetX value)? updateOffsetX,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateRadius value)? updateSpread,
    TResult Function(_UpdateColorR value)? updateColorR,
    TResult Function(_UpdateColorG value)? updateColorG,
    TResult Function(_UpdateColorB value)? updateColorB,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UpdateOffsetY value)? updateOffsetY,
    TResult Function(_UpdateOffsetX value)? updateOffsetX,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateRadius value)? updateSpread,
    TResult Function(_UpdateColorR value)? updateColorR,
    TResult Function(_UpdateColorG value)? updateColorG,
    TResult Function(_UpdateColorB value)? updateColorB,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ShadowEventCopyWith<$Res> {
  factory $ShadowEventCopyWith(
          ShadowEvent value, $Res Function(ShadowEvent) then) =
      _$ShadowEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$ShadowEventCopyWithImpl<$Res> implements $ShadowEventCopyWith<$Res> {
  _$ShadowEventCopyWithImpl(this._value, this._then);

  final ShadowEvent _value;
  // ignore: unused_field
  final $Res Function(ShadowEvent) _then;
}

/// @nodoc
abstract class _$InitialEventCopyWith<$Res> {
  factory _$InitialEventCopyWith(
          _InitialEvent value, $Res Function(_InitialEvent) then) =
      __$InitialEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$InitialEventCopyWithImpl<$Res> extends _$ShadowEventCopyWithImpl<$Res>
    implements _$InitialEventCopyWith<$Res> {
  __$InitialEventCopyWithImpl(
      _InitialEvent _value, $Res Function(_InitialEvent) _then)
      : super(_value, (v) => _then(v as _InitialEvent));

  @override
  _InitialEvent get _value => super._value as _InitialEvent;
}

/// @nodoc

class _$_InitialEvent implements _InitialEvent {
  const _$_InitialEvent();

  @override
  String toString() {
    return 'ShadowEvent.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _InitialEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(double value) updateOffsetY,
    required TResult Function(double value) updateOffsetX,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(double value) updateColorR,
    required TResult Function(double value) updateColorG,
    required TResult Function(double value) updateColorB,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(double value)? updateOffsetY,
    TResult Function(double value)? updateOffsetX,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(double value)? updateColorR,
    TResult Function(double value)? updateColorG,
    TResult Function(double value)? updateColorB,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(double value)? updateOffsetY,
    TResult Function(double value)? updateOffsetX,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(double value)? updateColorR,
    TResult Function(double value)? updateColorG,
    TResult Function(double value)? updateColorB,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UpdateOffsetY value) updateOffsetY,
    required TResult Function(_UpdateOffsetX value) updateOffsetX,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateRadius value) updateSpread,
    required TResult Function(_UpdateColorR value) updateColorR,
    required TResult Function(_UpdateColorG value) updateColorG,
    required TResult Function(_UpdateColorB value) updateColorB,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UpdateOffsetY value)? updateOffsetY,
    TResult Function(_UpdateOffsetX value)? updateOffsetX,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateRadius value)? updateSpread,
    TResult Function(_UpdateColorR value)? updateColorR,
    TResult Function(_UpdateColorG value)? updateColorG,
    TResult Function(_UpdateColorB value)? updateColorB,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UpdateOffsetY value)? updateOffsetY,
    TResult Function(_UpdateOffsetX value)? updateOffsetX,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateRadius value)? updateSpread,
    TResult Function(_UpdateColorR value)? updateColorR,
    TResult Function(_UpdateColorG value)? updateColorG,
    TResult Function(_UpdateColorB value)? updateColorB,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _InitialEvent implements ShadowEvent {
  const factory _InitialEvent() = _$_InitialEvent;
}

/// @nodoc
abstract class _$UpdateOffsetYCopyWith<$Res> {
  factory _$UpdateOffsetYCopyWith(
          _UpdateOffsetY value, $Res Function(_UpdateOffsetY) then) =
      __$UpdateOffsetYCopyWithImpl<$Res>;
  $Res call({double value});
}

/// @nodoc
class __$UpdateOffsetYCopyWithImpl<$Res> extends _$ShadowEventCopyWithImpl<$Res>
    implements _$UpdateOffsetYCopyWith<$Res> {
  __$UpdateOffsetYCopyWithImpl(
      _UpdateOffsetY _value, $Res Function(_UpdateOffsetY) _then)
      : super(_value, (v) => _then(v as _UpdateOffsetY));

  @override
  _UpdateOffsetY get _value => super._value as _UpdateOffsetY;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_UpdateOffsetY(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_UpdateOffsetY implements _UpdateOffsetY {
  const _$_UpdateOffsetY(this.value);

  @override
  final double value;

  @override
  String toString() {
    return 'ShadowEvent.updateOffsetY(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UpdateOffsetY &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$UpdateOffsetYCopyWith<_UpdateOffsetY> get copyWith =>
      __$UpdateOffsetYCopyWithImpl<_UpdateOffsetY>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(double value) updateOffsetY,
    required TResult Function(double value) updateOffsetX,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(double value) updateColorR,
    required TResult Function(double value) updateColorG,
    required TResult Function(double value) updateColorB,
  }) {
    return updateOffsetY(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(double value)? updateOffsetY,
    TResult Function(double value)? updateOffsetX,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(double value)? updateColorR,
    TResult Function(double value)? updateColorG,
    TResult Function(double value)? updateColorB,
  }) {
    return updateOffsetY?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(double value)? updateOffsetY,
    TResult Function(double value)? updateOffsetX,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(double value)? updateColorR,
    TResult Function(double value)? updateColorG,
    TResult Function(double value)? updateColorB,
    required TResult orElse(),
  }) {
    if (updateOffsetY != null) {
      return updateOffsetY(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UpdateOffsetY value) updateOffsetY,
    required TResult Function(_UpdateOffsetX value) updateOffsetX,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateRadius value) updateSpread,
    required TResult Function(_UpdateColorR value) updateColorR,
    required TResult Function(_UpdateColorG value) updateColorG,
    required TResult Function(_UpdateColorB value) updateColorB,
  }) {
    return updateOffsetY(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UpdateOffsetY value)? updateOffsetY,
    TResult Function(_UpdateOffsetX value)? updateOffsetX,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateRadius value)? updateSpread,
    TResult Function(_UpdateColorR value)? updateColorR,
    TResult Function(_UpdateColorG value)? updateColorG,
    TResult Function(_UpdateColorB value)? updateColorB,
  }) {
    return updateOffsetY?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UpdateOffsetY value)? updateOffsetY,
    TResult Function(_UpdateOffsetX value)? updateOffsetX,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateRadius value)? updateSpread,
    TResult Function(_UpdateColorR value)? updateColorR,
    TResult Function(_UpdateColorG value)? updateColorG,
    TResult Function(_UpdateColorB value)? updateColorB,
    required TResult orElse(),
  }) {
    if (updateOffsetY != null) {
      return updateOffsetY(this);
    }
    return orElse();
  }
}

abstract class _UpdateOffsetY implements ShadowEvent {
  const factory _UpdateOffsetY(double value) = _$_UpdateOffsetY;

  double get value;
  @JsonKey(ignore: true)
  _$UpdateOffsetYCopyWith<_UpdateOffsetY> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$UpdateOffsetXCopyWith<$Res> {
  factory _$UpdateOffsetXCopyWith(
          _UpdateOffsetX value, $Res Function(_UpdateOffsetX) then) =
      __$UpdateOffsetXCopyWithImpl<$Res>;
  $Res call({double value});
}

/// @nodoc
class __$UpdateOffsetXCopyWithImpl<$Res> extends _$ShadowEventCopyWithImpl<$Res>
    implements _$UpdateOffsetXCopyWith<$Res> {
  __$UpdateOffsetXCopyWithImpl(
      _UpdateOffsetX _value, $Res Function(_UpdateOffsetX) _then)
      : super(_value, (v) => _then(v as _UpdateOffsetX));

  @override
  _UpdateOffsetX get _value => super._value as _UpdateOffsetX;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_UpdateOffsetX(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_UpdateOffsetX implements _UpdateOffsetX {
  const _$_UpdateOffsetX(this.value);

  @override
  final double value;

  @override
  String toString() {
    return 'ShadowEvent.updateOffsetX(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UpdateOffsetX &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$UpdateOffsetXCopyWith<_UpdateOffsetX> get copyWith =>
      __$UpdateOffsetXCopyWithImpl<_UpdateOffsetX>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(double value) updateOffsetY,
    required TResult Function(double value) updateOffsetX,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(double value) updateColorR,
    required TResult Function(double value) updateColorG,
    required TResult Function(double value) updateColorB,
  }) {
    return updateOffsetX(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(double value)? updateOffsetY,
    TResult Function(double value)? updateOffsetX,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(double value)? updateColorR,
    TResult Function(double value)? updateColorG,
    TResult Function(double value)? updateColorB,
  }) {
    return updateOffsetX?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(double value)? updateOffsetY,
    TResult Function(double value)? updateOffsetX,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(double value)? updateColorR,
    TResult Function(double value)? updateColorG,
    TResult Function(double value)? updateColorB,
    required TResult orElse(),
  }) {
    if (updateOffsetX != null) {
      return updateOffsetX(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UpdateOffsetY value) updateOffsetY,
    required TResult Function(_UpdateOffsetX value) updateOffsetX,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateRadius value) updateSpread,
    required TResult Function(_UpdateColorR value) updateColorR,
    required TResult Function(_UpdateColorG value) updateColorG,
    required TResult Function(_UpdateColorB value) updateColorB,
  }) {
    return updateOffsetX(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UpdateOffsetY value)? updateOffsetY,
    TResult Function(_UpdateOffsetX value)? updateOffsetX,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateRadius value)? updateSpread,
    TResult Function(_UpdateColorR value)? updateColorR,
    TResult Function(_UpdateColorG value)? updateColorG,
    TResult Function(_UpdateColorB value)? updateColorB,
  }) {
    return updateOffsetX?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UpdateOffsetY value)? updateOffsetY,
    TResult Function(_UpdateOffsetX value)? updateOffsetX,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateRadius value)? updateSpread,
    TResult Function(_UpdateColorR value)? updateColorR,
    TResult Function(_UpdateColorG value)? updateColorG,
    TResult Function(_UpdateColorB value)? updateColorB,
    required TResult orElse(),
  }) {
    if (updateOffsetX != null) {
      return updateOffsetX(this);
    }
    return orElse();
  }
}

abstract class _UpdateOffsetX implements ShadowEvent {
  const factory _UpdateOffsetX(double value) = _$_UpdateOffsetX;

  double get value;
  @JsonKey(ignore: true)
  _$UpdateOffsetXCopyWith<_UpdateOffsetX> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$UpdateBlurCopyWith<$Res> {
  factory _$UpdateBlurCopyWith(
          _UpdateBlur value, $Res Function(_UpdateBlur) then) =
      __$UpdateBlurCopyWithImpl<$Res>;
  $Res call({double value});
}

/// @nodoc
class __$UpdateBlurCopyWithImpl<$Res> extends _$ShadowEventCopyWithImpl<$Res>
    implements _$UpdateBlurCopyWith<$Res> {
  __$UpdateBlurCopyWithImpl(
      _UpdateBlur _value, $Res Function(_UpdateBlur) _then)
      : super(_value, (v) => _then(v as _UpdateBlur));

  @override
  _UpdateBlur get _value => super._value as _UpdateBlur;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_UpdateBlur(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_UpdateBlur implements _UpdateBlur {
  const _$_UpdateBlur(this.value);

  @override
  final double value;

  @override
  String toString() {
    return 'ShadowEvent.updateBlur(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UpdateBlur &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$UpdateBlurCopyWith<_UpdateBlur> get copyWith =>
      __$UpdateBlurCopyWithImpl<_UpdateBlur>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(double value) updateOffsetY,
    required TResult Function(double value) updateOffsetX,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(double value) updateColorR,
    required TResult Function(double value) updateColorG,
    required TResult Function(double value) updateColorB,
  }) {
    return updateBlur(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(double value)? updateOffsetY,
    TResult Function(double value)? updateOffsetX,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(double value)? updateColorR,
    TResult Function(double value)? updateColorG,
    TResult Function(double value)? updateColorB,
  }) {
    return updateBlur?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(double value)? updateOffsetY,
    TResult Function(double value)? updateOffsetX,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(double value)? updateColorR,
    TResult Function(double value)? updateColorG,
    TResult Function(double value)? updateColorB,
    required TResult orElse(),
  }) {
    if (updateBlur != null) {
      return updateBlur(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UpdateOffsetY value) updateOffsetY,
    required TResult Function(_UpdateOffsetX value) updateOffsetX,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateRadius value) updateSpread,
    required TResult Function(_UpdateColorR value) updateColorR,
    required TResult Function(_UpdateColorG value) updateColorG,
    required TResult Function(_UpdateColorB value) updateColorB,
  }) {
    return updateBlur(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UpdateOffsetY value)? updateOffsetY,
    TResult Function(_UpdateOffsetX value)? updateOffsetX,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateRadius value)? updateSpread,
    TResult Function(_UpdateColorR value)? updateColorR,
    TResult Function(_UpdateColorG value)? updateColorG,
    TResult Function(_UpdateColorB value)? updateColorB,
  }) {
    return updateBlur?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UpdateOffsetY value)? updateOffsetY,
    TResult Function(_UpdateOffsetX value)? updateOffsetX,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateRadius value)? updateSpread,
    TResult Function(_UpdateColorR value)? updateColorR,
    TResult Function(_UpdateColorG value)? updateColorG,
    TResult Function(_UpdateColorB value)? updateColorB,
    required TResult orElse(),
  }) {
    if (updateBlur != null) {
      return updateBlur(this);
    }
    return orElse();
  }
}

abstract class _UpdateBlur implements ShadowEvent {
  const factory _UpdateBlur(double value) = _$_UpdateBlur;

  double get value;
  @JsonKey(ignore: true)
  _$UpdateBlurCopyWith<_UpdateBlur> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$UpdateRadiusCopyWith<$Res> {
  factory _$UpdateRadiusCopyWith(
          _UpdateRadius value, $Res Function(_UpdateRadius) then) =
      __$UpdateRadiusCopyWithImpl<$Res>;
  $Res call({double value});
}

/// @nodoc
class __$UpdateRadiusCopyWithImpl<$Res> extends _$ShadowEventCopyWithImpl<$Res>
    implements _$UpdateRadiusCopyWith<$Res> {
  __$UpdateRadiusCopyWithImpl(
      _UpdateRadius _value, $Res Function(_UpdateRadius) _then)
      : super(_value, (v) => _then(v as _UpdateRadius));

  @override
  _UpdateRadius get _value => super._value as _UpdateRadius;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_UpdateRadius(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_UpdateRadius implements _UpdateRadius {
  const _$_UpdateRadius(this.value);

  @override
  final double value;

  @override
  String toString() {
    return 'ShadowEvent.updateSpread(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UpdateRadius &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$UpdateRadiusCopyWith<_UpdateRadius> get copyWith =>
      __$UpdateRadiusCopyWithImpl<_UpdateRadius>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(double value) updateOffsetY,
    required TResult Function(double value) updateOffsetX,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(double value) updateColorR,
    required TResult Function(double value) updateColorG,
    required TResult Function(double value) updateColorB,
  }) {
    return updateSpread(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(double value)? updateOffsetY,
    TResult Function(double value)? updateOffsetX,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(double value)? updateColorR,
    TResult Function(double value)? updateColorG,
    TResult Function(double value)? updateColorB,
  }) {
    return updateSpread?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(double value)? updateOffsetY,
    TResult Function(double value)? updateOffsetX,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(double value)? updateColorR,
    TResult Function(double value)? updateColorG,
    TResult Function(double value)? updateColorB,
    required TResult orElse(),
  }) {
    if (updateSpread != null) {
      return updateSpread(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UpdateOffsetY value) updateOffsetY,
    required TResult Function(_UpdateOffsetX value) updateOffsetX,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateRadius value) updateSpread,
    required TResult Function(_UpdateColorR value) updateColorR,
    required TResult Function(_UpdateColorG value) updateColorG,
    required TResult Function(_UpdateColorB value) updateColorB,
  }) {
    return updateSpread(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UpdateOffsetY value)? updateOffsetY,
    TResult Function(_UpdateOffsetX value)? updateOffsetX,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateRadius value)? updateSpread,
    TResult Function(_UpdateColorR value)? updateColorR,
    TResult Function(_UpdateColorG value)? updateColorG,
    TResult Function(_UpdateColorB value)? updateColorB,
  }) {
    return updateSpread?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UpdateOffsetY value)? updateOffsetY,
    TResult Function(_UpdateOffsetX value)? updateOffsetX,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateRadius value)? updateSpread,
    TResult Function(_UpdateColorR value)? updateColorR,
    TResult Function(_UpdateColorG value)? updateColorG,
    TResult Function(_UpdateColorB value)? updateColorB,
    required TResult orElse(),
  }) {
    if (updateSpread != null) {
      return updateSpread(this);
    }
    return orElse();
  }
}

abstract class _UpdateRadius implements ShadowEvent {
  const factory _UpdateRadius(double value) = _$_UpdateRadius;

  double get value;
  @JsonKey(ignore: true)
  _$UpdateRadiusCopyWith<_UpdateRadius> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$UpdateColorRCopyWith<$Res> {
  factory _$UpdateColorRCopyWith(
          _UpdateColorR value, $Res Function(_UpdateColorR) then) =
      __$UpdateColorRCopyWithImpl<$Res>;
  $Res call({double value});
}

/// @nodoc
class __$UpdateColorRCopyWithImpl<$Res> extends _$ShadowEventCopyWithImpl<$Res>
    implements _$UpdateColorRCopyWith<$Res> {
  __$UpdateColorRCopyWithImpl(
      _UpdateColorR _value, $Res Function(_UpdateColorR) _then)
      : super(_value, (v) => _then(v as _UpdateColorR));

  @override
  _UpdateColorR get _value => super._value as _UpdateColorR;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_UpdateColorR(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_UpdateColorR implements _UpdateColorR {
  const _$_UpdateColorR(this.value);

  @override
  final double value;

  @override
  String toString() {
    return 'ShadowEvent.updateColorR(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UpdateColorR &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$UpdateColorRCopyWith<_UpdateColorR> get copyWith =>
      __$UpdateColorRCopyWithImpl<_UpdateColorR>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(double value) updateOffsetY,
    required TResult Function(double value) updateOffsetX,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(double value) updateColorR,
    required TResult Function(double value) updateColorG,
    required TResult Function(double value) updateColorB,
  }) {
    return updateColorR(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(double value)? updateOffsetY,
    TResult Function(double value)? updateOffsetX,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(double value)? updateColorR,
    TResult Function(double value)? updateColorG,
    TResult Function(double value)? updateColorB,
  }) {
    return updateColorR?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(double value)? updateOffsetY,
    TResult Function(double value)? updateOffsetX,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(double value)? updateColorR,
    TResult Function(double value)? updateColorG,
    TResult Function(double value)? updateColorB,
    required TResult orElse(),
  }) {
    if (updateColorR != null) {
      return updateColorR(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UpdateOffsetY value) updateOffsetY,
    required TResult Function(_UpdateOffsetX value) updateOffsetX,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateRadius value) updateSpread,
    required TResult Function(_UpdateColorR value) updateColorR,
    required TResult Function(_UpdateColorG value) updateColorG,
    required TResult Function(_UpdateColorB value) updateColorB,
  }) {
    return updateColorR(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UpdateOffsetY value)? updateOffsetY,
    TResult Function(_UpdateOffsetX value)? updateOffsetX,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateRadius value)? updateSpread,
    TResult Function(_UpdateColorR value)? updateColorR,
    TResult Function(_UpdateColorG value)? updateColorG,
    TResult Function(_UpdateColorB value)? updateColorB,
  }) {
    return updateColorR?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UpdateOffsetY value)? updateOffsetY,
    TResult Function(_UpdateOffsetX value)? updateOffsetX,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateRadius value)? updateSpread,
    TResult Function(_UpdateColorR value)? updateColorR,
    TResult Function(_UpdateColorG value)? updateColorG,
    TResult Function(_UpdateColorB value)? updateColorB,
    required TResult orElse(),
  }) {
    if (updateColorR != null) {
      return updateColorR(this);
    }
    return orElse();
  }
}

abstract class _UpdateColorR implements ShadowEvent {
  const factory _UpdateColorR(double value) = _$_UpdateColorR;

  double get value;
  @JsonKey(ignore: true)
  _$UpdateColorRCopyWith<_UpdateColorR> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$UpdateColorGCopyWith<$Res> {
  factory _$UpdateColorGCopyWith(
          _UpdateColorG value, $Res Function(_UpdateColorG) then) =
      __$UpdateColorGCopyWithImpl<$Res>;
  $Res call({double value});
}

/// @nodoc
class __$UpdateColorGCopyWithImpl<$Res> extends _$ShadowEventCopyWithImpl<$Res>
    implements _$UpdateColorGCopyWith<$Res> {
  __$UpdateColorGCopyWithImpl(
      _UpdateColorG _value, $Res Function(_UpdateColorG) _then)
      : super(_value, (v) => _then(v as _UpdateColorG));

  @override
  _UpdateColorG get _value => super._value as _UpdateColorG;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_UpdateColorG(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_UpdateColorG implements _UpdateColorG {
  const _$_UpdateColorG(this.value);

  @override
  final double value;

  @override
  String toString() {
    return 'ShadowEvent.updateColorG(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UpdateColorG &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$UpdateColorGCopyWith<_UpdateColorG> get copyWith =>
      __$UpdateColorGCopyWithImpl<_UpdateColorG>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(double value) updateOffsetY,
    required TResult Function(double value) updateOffsetX,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(double value) updateColorR,
    required TResult Function(double value) updateColorG,
    required TResult Function(double value) updateColorB,
  }) {
    return updateColorG(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(double value)? updateOffsetY,
    TResult Function(double value)? updateOffsetX,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(double value)? updateColorR,
    TResult Function(double value)? updateColorG,
    TResult Function(double value)? updateColorB,
  }) {
    return updateColorG?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(double value)? updateOffsetY,
    TResult Function(double value)? updateOffsetX,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(double value)? updateColorR,
    TResult Function(double value)? updateColorG,
    TResult Function(double value)? updateColorB,
    required TResult orElse(),
  }) {
    if (updateColorG != null) {
      return updateColorG(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UpdateOffsetY value) updateOffsetY,
    required TResult Function(_UpdateOffsetX value) updateOffsetX,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateRadius value) updateSpread,
    required TResult Function(_UpdateColorR value) updateColorR,
    required TResult Function(_UpdateColorG value) updateColorG,
    required TResult Function(_UpdateColorB value) updateColorB,
  }) {
    return updateColorG(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UpdateOffsetY value)? updateOffsetY,
    TResult Function(_UpdateOffsetX value)? updateOffsetX,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateRadius value)? updateSpread,
    TResult Function(_UpdateColorR value)? updateColorR,
    TResult Function(_UpdateColorG value)? updateColorG,
    TResult Function(_UpdateColorB value)? updateColorB,
  }) {
    return updateColorG?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UpdateOffsetY value)? updateOffsetY,
    TResult Function(_UpdateOffsetX value)? updateOffsetX,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateRadius value)? updateSpread,
    TResult Function(_UpdateColorR value)? updateColorR,
    TResult Function(_UpdateColorG value)? updateColorG,
    TResult Function(_UpdateColorB value)? updateColorB,
    required TResult orElse(),
  }) {
    if (updateColorG != null) {
      return updateColorG(this);
    }
    return orElse();
  }
}

abstract class _UpdateColorG implements ShadowEvent {
  const factory _UpdateColorG(double value) = _$_UpdateColorG;

  double get value;
  @JsonKey(ignore: true)
  _$UpdateColorGCopyWith<_UpdateColorG> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$UpdateColorBCopyWith<$Res> {
  factory _$UpdateColorBCopyWith(
          _UpdateColorB value, $Res Function(_UpdateColorB) then) =
      __$UpdateColorBCopyWithImpl<$Res>;
  $Res call({double value});
}

/// @nodoc
class __$UpdateColorBCopyWithImpl<$Res> extends _$ShadowEventCopyWithImpl<$Res>
    implements _$UpdateColorBCopyWith<$Res> {
  __$UpdateColorBCopyWithImpl(
      _UpdateColorB _value, $Res Function(_UpdateColorB) _then)
      : super(_value, (v) => _then(v as _UpdateColorB));

  @override
  _UpdateColorB get _value => super._value as _UpdateColorB;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_UpdateColorB(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_UpdateColorB implements _UpdateColorB {
  const _$_UpdateColorB(this.value);

  @override
  final double value;

  @override
  String toString() {
    return 'ShadowEvent.updateColorB(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UpdateColorB &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  _$UpdateColorBCopyWith<_UpdateColorB> get copyWith =>
      __$UpdateColorBCopyWithImpl<_UpdateColorB>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(double value) updateOffsetY,
    required TResult Function(double value) updateOffsetX,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(double value) updateColorR,
    required TResult Function(double value) updateColorG,
    required TResult Function(double value) updateColorB,
  }) {
    return updateColorB(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(double value)? updateOffsetY,
    TResult Function(double value)? updateOffsetX,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(double value)? updateColorR,
    TResult Function(double value)? updateColorG,
    TResult Function(double value)? updateColorB,
  }) {
    return updateColorB?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(double value)? updateOffsetY,
    TResult Function(double value)? updateOffsetX,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(double value)? updateColorR,
    TResult Function(double value)? updateColorG,
    TResult Function(double value)? updateColorB,
    required TResult orElse(),
  }) {
    if (updateColorB != null) {
      return updateColorB(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UpdateOffsetY value) updateOffsetY,
    required TResult Function(_UpdateOffsetX value) updateOffsetX,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateRadius value) updateSpread,
    required TResult Function(_UpdateColorR value) updateColorR,
    required TResult Function(_UpdateColorG value) updateColorG,
    required TResult Function(_UpdateColorB value) updateColorB,
  }) {
    return updateColorB(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UpdateOffsetY value)? updateOffsetY,
    TResult Function(_UpdateOffsetX value)? updateOffsetX,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateRadius value)? updateSpread,
    TResult Function(_UpdateColorR value)? updateColorR,
    TResult Function(_UpdateColorG value)? updateColorG,
    TResult Function(_UpdateColorB value)? updateColorB,
  }) {
    return updateColorB?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UpdateOffsetY value)? updateOffsetY,
    TResult Function(_UpdateOffsetX value)? updateOffsetX,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateRadius value)? updateSpread,
    TResult Function(_UpdateColorR value)? updateColorR,
    TResult Function(_UpdateColorG value)? updateColorG,
    TResult Function(_UpdateColorB value)? updateColorB,
    required TResult orElse(),
  }) {
    if (updateColorB != null) {
      return updateColorB(this);
    }
    return orElse();
  }
}

abstract class _UpdateColorB implements ShadowEvent {
  const factory _UpdateColorB(double value) = _$_UpdateColorB;

  double get value;
  @JsonKey(ignore: true)
  _$UpdateColorBCopyWith<_UpdateColorB> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$ShadowStateTearOff {
  const _$ShadowStateTearOff();

  _InitialState initial() {
    return const _InitialState();
  }

  _UpdateShadow updateShadow(
      {required Offset offset,
      required Color color,
      required double blurRadius,
      required double spreadRadius}) {
    return _UpdateShadow(
      offset: offset,
      color: color,
      blurRadius: blurRadius,
      spreadRadius: spreadRadius,
    );
  }
}

/// @nodoc
const $ShadowState = _$ShadowStateTearOff();

/// @nodoc
mixin _$ShadowState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(
            Offset offset, Color color, double blurRadius, double spreadRadius)
        updateShadow,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(
            Offset offset, Color color, double blurRadius, double spreadRadius)?
        updateShadow,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(
            Offset offset, Color color, double blurRadius, double spreadRadius)?
        updateShadow,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialState value) initial,
    required TResult Function(_UpdateShadow value) updateShadow,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialState value)? initial,
    TResult Function(_UpdateShadow value)? updateShadow,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialState value)? initial,
    TResult Function(_UpdateShadow value)? updateShadow,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ShadowStateCopyWith<$Res> {
  factory $ShadowStateCopyWith(
          ShadowState value, $Res Function(ShadowState) then) =
      _$ShadowStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$ShadowStateCopyWithImpl<$Res> implements $ShadowStateCopyWith<$Res> {
  _$ShadowStateCopyWithImpl(this._value, this._then);

  final ShadowState _value;
  // ignore: unused_field
  final $Res Function(ShadowState) _then;
}

/// @nodoc
abstract class _$InitialStateCopyWith<$Res> {
  factory _$InitialStateCopyWith(
          _InitialState value, $Res Function(_InitialState) then) =
      __$InitialStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$InitialStateCopyWithImpl<$Res> extends _$ShadowStateCopyWithImpl<$Res>
    implements _$InitialStateCopyWith<$Res> {
  __$InitialStateCopyWithImpl(
      _InitialState _value, $Res Function(_InitialState) _then)
      : super(_value, (v) => _then(v as _InitialState));

  @override
  _InitialState get _value => super._value as _InitialState;
}

/// @nodoc

class _$_InitialState implements _InitialState {
  const _$_InitialState();

  @override
  String toString() {
    return 'ShadowState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _InitialState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(
            Offset offset, Color color, double blurRadius, double spreadRadius)
        updateShadow,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(
            Offset offset, Color color, double blurRadius, double spreadRadius)?
        updateShadow,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(
            Offset offset, Color color, double blurRadius, double spreadRadius)?
        updateShadow,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialState value) initial,
    required TResult Function(_UpdateShadow value) updateShadow,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialState value)? initial,
    TResult Function(_UpdateShadow value)? updateShadow,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialState value)? initial,
    TResult Function(_UpdateShadow value)? updateShadow,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _InitialState implements ShadowState {
  const factory _InitialState() = _$_InitialState;
}

/// @nodoc
abstract class _$UpdateShadowCopyWith<$Res> {
  factory _$UpdateShadowCopyWith(
          _UpdateShadow value, $Res Function(_UpdateShadow) then) =
      __$UpdateShadowCopyWithImpl<$Res>;
  $Res call(
      {Offset offset, Color color, double blurRadius, double spreadRadius});
}

/// @nodoc
class __$UpdateShadowCopyWithImpl<$Res> extends _$ShadowStateCopyWithImpl<$Res>
    implements _$UpdateShadowCopyWith<$Res> {
  __$UpdateShadowCopyWithImpl(
      _UpdateShadow _value, $Res Function(_UpdateShadow) _then)
      : super(_value, (v) => _then(v as _UpdateShadow));

  @override
  _UpdateShadow get _value => super._value as _UpdateShadow;

  @override
  $Res call({
    Object? offset = freezed,
    Object? color = freezed,
    Object? blurRadius = freezed,
    Object? spreadRadius = freezed,
  }) {
    return _then(_UpdateShadow(
      offset: offset == freezed
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as Offset,
      color: color == freezed
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color,
      blurRadius: blurRadius == freezed
          ? _value.blurRadius
          : blurRadius // ignore: cast_nullable_to_non_nullable
              as double,
      spreadRadius: spreadRadius == freezed
          ? _value.spreadRadius
          : spreadRadius // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_UpdateShadow implements _UpdateShadow {
  const _$_UpdateShadow(
      {required this.offset,
      required this.color,
      required this.blurRadius,
      required this.spreadRadius});

  @override
  final Offset offset;
  @override
  final Color color;
  @override
  final double blurRadius;
  @override
  final double spreadRadius;

  @override
  String toString() {
    return 'ShadowState.updateShadow(offset: $offset, color: $color, blurRadius: $blurRadius, spreadRadius: $spreadRadius)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UpdateShadow &&
            const DeepCollectionEquality().equals(other.offset, offset) &&
            const DeepCollectionEquality().equals(other.color, color) &&
            const DeepCollectionEquality()
                .equals(other.blurRadius, blurRadius) &&
            const DeepCollectionEquality()
                .equals(other.spreadRadius, spreadRadius));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(offset),
      const DeepCollectionEquality().hash(color),
      const DeepCollectionEquality().hash(blurRadius),
      const DeepCollectionEquality().hash(spreadRadius));

  @JsonKey(ignore: true)
  @override
  _$UpdateShadowCopyWith<_UpdateShadow> get copyWith =>
      __$UpdateShadowCopyWithImpl<_UpdateShadow>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(
            Offset offset, Color color, double blurRadius, double spreadRadius)
        updateShadow,
  }) {
    return updateShadow(offset, color, blurRadius, spreadRadius);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(
            Offset offset, Color color, double blurRadius, double spreadRadius)?
        updateShadow,
  }) {
    return updateShadow?.call(offset, color, blurRadius, spreadRadius);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(
            Offset offset, Color color, double blurRadius, double spreadRadius)?
        updateShadow,
    required TResult orElse(),
  }) {
    if (updateShadow != null) {
      return updateShadow(offset, color, blurRadius, spreadRadius);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialState value) initial,
    required TResult Function(_UpdateShadow value) updateShadow,
  }) {
    return updateShadow(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_InitialState value)? initial,
    TResult Function(_UpdateShadow value)? updateShadow,
  }) {
    return updateShadow?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialState value)? initial,
    TResult Function(_UpdateShadow value)? updateShadow,
    required TResult orElse(),
  }) {
    if (updateShadow != null) {
      return updateShadow(this);
    }
    return orElse();
  }
}

abstract class _UpdateShadow implements ShadowState {
  const factory _UpdateShadow(
      {required Offset offset,
      required Color color,
      required double blurRadius,
      required double spreadRadius}) = _$_UpdateShadow;

  Offset get offset;
  Color get color;
  double get blurRadius;
  double get spreadRadius;
  @JsonKey(ignore: true)
  _$UpdateShadowCopyWith<_UpdateShadow> get copyWith =>
      throw _privateConstructorUsedError;
}
