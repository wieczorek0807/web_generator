// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'shadow_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$ShadowEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(double value) updateOffsetY,
    required TResult Function(double value) updateOffsetX,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(Color value) updateAnimatedBoxColor,
    required TResult Function(Color value) updateShadowColor,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(double value)? updateOffsetY,
    TResult? Function(double value)? updateOffsetX,
    TResult? Function(double value)? updateBlur,
    TResult? Function(double value)? updateSpread,
    TResult? Function(Color value)? updateAnimatedBoxColor,
    TResult? Function(Color value)? updateShadowColor,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(double value)? updateOffsetY,
    TResult Function(double value)? updateOffsetX,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(Color value)? updateAnimatedBoxColor,
    TResult Function(Color value)? updateShadowColor,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UpdateOffsetY value) updateOffsetY,
    required TResult Function(_UpdateOffsetX value) updateOffsetX,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateRadius value) updateSpread,
    required TResult Function(_UpdateAnimatedBoxColor value)
        updateAnimatedBoxColor,
    required TResult Function(_UpdateShadowColor value) updateShadowColor,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialEvent value)? initial,
    TResult? Function(_UpdateOffsetY value)? updateOffsetY,
    TResult? Function(_UpdateOffsetX value)? updateOffsetX,
    TResult? Function(_UpdateBlur value)? updateBlur,
    TResult? Function(_UpdateRadius value)? updateSpread,
    TResult? Function(_UpdateAnimatedBoxColor value)? updateAnimatedBoxColor,
    TResult? Function(_UpdateShadowColor value)? updateShadowColor,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UpdateOffsetY value)? updateOffsetY,
    TResult Function(_UpdateOffsetX value)? updateOffsetX,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateRadius value)? updateSpread,
    TResult Function(_UpdateAnimatedBoxColor value)? updateAnimatedBoxColor,
    TResult Function(_UpdateShadowColor value)? updateShadowColor,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ShadowEventCopyWith<$Res> {
  factory $ShadowEventCopyWith(
          ShadowEvent value, $Res Function(ShadowEvent) then) =
      _$ShadowEventCopyWithImpl<$Res, ShadowEvent>;
}

/// @nodoc
class _$ShadowEventCopyWithImpl<$Res, $Val extends ShadowEvent>
    implements $ShadowEventCopyWith<$Res> {
  _$ShadowEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_InitialEventCopyWith<$Res> {
  factory _$$_InitialEventCopyWith(
          _$_InitialEvent value, $Res Function(_$_InitialEvent) then) =
      __$$_InitialEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_InitialEventCopyWithImpl<$Res>
    extends _$ShadowEventCopyWithImpl<$Res, _$_InitialEvent>
    implements _$$_InitialEventCopyWith<$Res> {
  __$$_InitialEventCopyWithImpl(
      _$_InitialEvent _value, $Res Function(_$_InitialEvent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_InitialEvent with DiagnosticableTreeMixin implements _InitialEvent {
  const _$_InitialEvent();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ShadowEvent.initial()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'ShadowEvent.initial'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_InitialEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(double value) updateOffsetY,
    required TResult Function(double value) updateOffsetX,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(Color value) updateAnimatedBoxColor,
    required TResult Function(Color value) updateShadowColor,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(double value)? updateOffsetY,
    TResult? Function(double value)? updateOffsetX,
    TResult? Function(double value)? updateBlur,
    TResult? Function(double value)? updateSpread,
    TResult? Function(Color value)? updateAnimatedBoxColor,
    TResult? Function(Color value)? updateShadowColor,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(double value)? updateOffsetY,
    TResult Function(double value)? updateOffsetX,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(Color value)? updateAnimatedBoxColor,
    TResult Function(Color value)? updateShadowColor,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UpdateOffsetY value) updateOffsetY,
    required TResult Function(_UpdateOffsetX value) updateOffsetX,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateRadius value) updateSpread,
    required TResult Function(_UpdateAnimatedBoxColor value)
        updateAnimatedBoxColor,
    required TResult Function(_UpdateShadowColor value) updateShadowColor,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialEvent value)? initial,
    TResult? Function(_UpdateOffsetY value)? updateOffsetY,
    TResult? Function(_UpdateOffsetX value)? updateOffsetX,
    TResult? Function(_UpdateBlur value)? updateBlur,
    TResult? Function(_UpdateRadius value)? updateSpread,
    TResult? Function(_UpdateAnimatedBoxColor value)? updateAnimatedBoxColor,
    TResult? Function(_UpdateShadowColor value)? updateShadowColor,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UpdateOffsetY value)? updateOffsetY,
    TResult Function(_UpdateOffsetX value)? updateOffsetX,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateRadius value)? updateSpread,
    TResult Function(_UpdateAnimatedBoxColor value)? updateAnimatedBoxColor,
    TResult Function(_UpdateShadowColor value)? updateShadowColor,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _InitialEvent implements ShadowEvent {
  const factory _InitialEvent() = _$_InitialEvent;
}

/// @nodoc
abstract class _$$_UpdateOffsetYCopyWith<$Res> {
  factory _$$_UpdateOffsetYCopyWith(
          _$_UpdateOffsetY value, $Res Function(_$_UpdateOffsetY) then) =
      __$$_UpdateOffsetYCopyWithImpl<$Res>;
  @useResult
  $Res call({double value});
}

/// @nodoc
class __$$_UpdateOffsetYCopyWithImpl<$Res>
    extends _$ShadowEventCopyWithImpl<$Res, _$_UpdateOffsetY>
    implements _$$_UpdateOffsetYCopyWith<$Res> {
  __$$_UpdateOffsetYCopyWithImpl(
      _$_UpdateOffsetY _value, $Res Function(_$_UpdateOffsetY) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_UpdateOffsetY(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_UpdateOffsetY with DiagnosticableTreeMixin implements _UpdateOffsetY {
  const _$_UpdateOffsetY(this.value);

  @override
  final double value;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ShadowEvent.updateOffsetY(value: $value)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ShadowEvent.updateOffsetY'))
      ..add(DiagnosticsProperty('value', value));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateOffsetY &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpdateOffsetYCopyWith<_$_UpdateOffsetY> get copyWith =>
      __$$_UpdateOffsetYCopyWithImpl<_$_UpdateOffsetY>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(double value) updateOffsetY,
    required TResult Function(double value) updateOffsetX,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(Color value) updateAnimatedBoxColor,
    required TResult Function(Color value) updateShadowColor,
  }) {
    return updateOffsetY(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(double value)? updateOffsetY,
    TResult? Function(double value)? updateOffsetX,
    TResult? Function(double value)? updateBlur,
    TResult? Function(double value)? updateSpread,
    TResult? Function(Color value)? updateAnimatedBoxColor,
    TResult? Function(Color value)? updateShadowColor,
  }) {
    return updateOffsetY?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(double value)? updateOffsetY,
    TResult Function(double value)? updateOffsetX,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(Color value)? updateAnimatedBoxColor,
    TResult Function(Color value)? updateShadowColor,
    required TResult orElse(),
  }) {
    if (updateOffsetY != null) {
      return updateOffsetY(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UpdateOffsetY value) updateOffsetY,
    required TResult Function(_UpdateOffsetX value) updateOffsetX,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateRadius value) updateSpread,
    required TResult Function(_UpdateAnimatedBoxColor value)
        updateAnimatedBoxColor,
    required TResult Function(_UpdateShadowColor value) updateShadowColor,
  }) {
    return updateOffsetY(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialEvent value)? initial,
    TResult? Function(_UpdateOffsetY value)? updateOffsetY,
    TResult? Function(_UpdateOffsetX value)? updateOffsetX,
    TResult? Function(_UpdateBlur value)? updateBlur,
    TResult? Function(_UpdateRadius value)? updateSpread,
    TResult? Function(_UpdateAnimatedBoxColor value)? updateAnimatedBoxColor,
    TResult? Function(_UpdateShadowColor value)? updateShadowColor,
  }) {
    return updateOffsetY?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UpdateOffsetY value)? updateOffsetY,
    TResult Function(_UpdateOffsetX value)? updateOffsetX,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateRadius value)? updateSpread,
    TResult Function(_UpdateAnimatedBoxColor value)? updateAnimatedBoxColor,
    TResult Function(_UpdateShadowColor value)? updateShadowColor,
    required TResult orElse(),
  }) {
    if (updateOffsetY != null) {
      return updateOffsetY(this);
    }
    return orElse();
  }
}

abstract class _UpdateOffsetY implements ShadowEvent {
  const factory _UpdateOffsetY(final double value) = _$_UpdateOffsetY;

  double get value;
  @JsonKey(ignore: true)
  _$$_UpdateOffsetYCopyWith<_$_UpdateOffsetY> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UpdateOffsetXCopyWith<$Res> {
  factory _$$_UpdateOffsetXCopyWith(
          _$_UpdateOffsetX value, $Res Function(_$_UpdateOffsetX) then) =
      __$$_UpdateOffsetXCopyWithImpl<$Res>;
  @useResult
  $Res call({double value});
}

/// @nodoc
class __$$_UpdateOffsetXCopyWithImpl<$Res>
    extends _$ShadowEventCopyWithImpl<$Res, _$_UpdateOffsetX>
    implements _$$_UpdateOffsetXCopyWith<$Res> {
  __$$_UpdateOffsetXCopyWithImpl(
      _$_UpdateOffsetX _value, $Res Function(_$_UpdateOffsetX) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_UpdateOffsetX(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_UpdateOffsetX with DiagnosticableTreeMixin implements _UpdateOffsetX {
  const _$_UpdateOffsetX(this.value);

  @override
  final double value;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ShadowEvent.updateOffsetX(value: $value)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ShadowEvent.updateOffsetX'))
      ..add(DiagnosticsProperty('value', value));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateOffsetX &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpdateOffsetXCopyWith<_$_UpdateOffsetX> get copyWith =>
      __$$_UpdateOffsetXCopyWithImpl<_$_UpdateOffsetX>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(double value) updateOffsetY,
    required TResult Function(double value) updateOffsetX,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(Color value) updateAnimatedBoxColor,
    required TResult Function(Color value) updateShadowColor,
  }) {
    return updateOffsetX(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(double value)? updateOffsetY,
    TResult? Function(double value)? updateOffsetX,
    TResult? Function(double value)? updateBlur,
    TResult? Function(double value)? updateSpread,
    TResult? Function(Color value)? updateAnimatedBoxColor,
    TResult? Function(Color value)? updateShadowColor,
  }) {
    return updateOffsetX?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(double value)? updateOffsetY,
    TResult Function(double value)? updateOffsetX,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(Color value)? updateAnimatedBoxColor,
    TResult Function(Color value)? updateShadowColor,
    required TResult orElse(),
  }) {
    if (updateOffsetX != null) {
      return updateOffsetX(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UpdateOffsetY value) updateOffsetY,
    required TResult Function(_UpdateOffsetX value) updateOffsetX,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateRadius value) updateSpread,
    required TResult Function(_UpdateAnimatedBoxColor value)
        updateAnimatedBoxColor,
    required TResult Function(_UpdateShadowColor value) updateShadowColor,
  }) {
    return updateOffsetX(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialEvent value)? initial,
    TResult? Function(_UpdateOffsetY value)? updateOffsetY,
    TResult? Function(_UpdateOffsetX value)? updateOffsetX,
    TResult? Function(_UpdateBlur value)? updateBlur,
    TResult? Function(_UpdateRadius value)? updateSpread,
    TResult? Function(_UpdateAnimatedBoxColor value)? updateAnimatedBoxColor,
    TResult? Function(_UpdateShadowColor value)? updateShadowColor,
  }) {
    return updateOffsetX?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UpdateOffsetY value)? updateOffsetY,
    TResult Function(_UpdateOffsetX value)? updateOffsetX,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateRadius value)? updateSpread,
    TResult Function(_UpdateAnimatedBoxColor value)? updateAnimatedBoxColor,
    TResult Function(_UpdateShadowColor value)? updateShadowColor,
    required TResult orElse(),
  }) {
    if (updateOffsetX != null) {
      return updateOffsetX(this);
    }
    return orElse();
  }
}

abstract class _UpdateOffsetX implements ShadowEvent {
  const factory _UpdateOffsetX(final double value) = _$_UpdateOffsetX;

  double get value;
  @JsonKey(ignore: true)
  _$$_UpdateOffsetXCopyWith<_$_UpdateOffsetX> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UpdateBlurCopyWith<$Res> {
  factory _$$_UpdateBlurCopyWith(
          _$_UpdateBlur value, $Res Function(_$_UpdateBlur) then) =
      __$$_UpdateBlurCopyWithImpl<$Res>;
  @useResult
  $Res call({double value});
}

/// @nodoc
class __$$_UpdateBlurCopyWithImpl<$Res>
    extends _$ShadowEventCopyWithImpl<$Res, _$_UpdateBlur>
    implements _$$_UpdateBlurCopyWith<$Res> {
  __$$_UpdateBlurCopyWithImpl(
      _$_UpdateBlur _value, $Res Function(_$_UpdateBlur) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_UpdateBlur(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_UpdateBlur with DiagnosticableTreeMixin implements _UpdateBlur {
  const _$_UpdateBlur(this.value);

  @override
  final double value;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ShadowEvent.updateBlur(value: $value)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ShadowEvent.updateBlur'))
      ..add(DiagnosticsProperty('value', value));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateBlur &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpdateBlurCopyWith<_$_UpdateBlur> get copyWith =>
      __$$_UpdateBlurCopyWithImpl<_$_UpdateBlur>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(double value) updateOffsetY,
    required TResult Function(double value) updateOffsetX,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(Color value) updateAnimatedBoxColor,
    required TResult Function(Color value) updateShadowColor,
  }) {
    return updateBlur(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(double value)? updateOffsetY,
    TResult? Function(double value)? updateOffsetX,
    TResult? Function(double value)? updateBlur,
    TResult? Function(double value)? updateSpread,
    TResult? Function(Color value)? updateAnimatedBoxColor,
    TResult? Function(Color value)? updateShadowColor,
  }) {
    return updateBlur?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(double value)? updateOffsetY,
    TResult Function(double value)? updateOffsetX,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(Color value)? updateAnimatedBoxColor,
    TResult Function(Color value)? updateShadowColor,
    required TResult orElse(),
  }) {
    if (updateBlur != null) {
      return updateBlur(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UpdateOffsetY value) updateOffsetY,
    required TResult Function(_UpdateOffsetX value) updateOffsetX,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateRadius value) updateSpread,
    required TResult Function(_UpdateAnimatedBoxColor value)
        updateAnimatedBoxColor,
    required TResult Function(_UpdateShadowColor value) updateShadowColor,
  }) {
    return updateBlur(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialEvent value)? initial,
    TResult? Function(_UpdateOffsetY value)? updateOffsetY,
    TResult? Function(_UpdateOffsetX value)? updateOffsetX,
    TResult? Function(_UpdateBlur value)? updateBlur,
    TResult? Function(_UpdateRadius value)? updateSpread,
    TResult? Function(_UpdateAnimatedBoxColor value)? updateAnimatedBoxColor,
    TResult? Function(_UpdateShadowColor value)? updateShadowColor,
  }) {
    return updateBlur?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UpdateOffsetY value)? updateOffsetY,
    TResult Function(_UpdateOffsetX value)? updateOffsetX,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateRadius value)? updateSpread,
    TResult Function(_UpdateAnimatedBoxColor value)? updateAnimatedBoxColor,
    TResult Function(_UpdateShadowColor value)? updateShadowColor,
    required TResult orElse(),
  }) {
    if (updateBlur != null) {
      return updateBlur(this);
    }
    return orElse();
  }
}

abstract class _UpdateBlur implements ShadowEvent {
  const factory _UpdateBlur(final double value) = _$_UpdateBlur;

  double get value;
  @JsonKey(ignore: true)
  _$$_UpdateBlurCopyWith<_$_UpdateBlur> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UpdateRadiusCopyWith<$Res> {
  factory _$$_UpdateRadiusCopyWith(
          _$_UpdateRadius value, $Res Function(_$_UpdateRadius) then) =
      __$$_UpdateRadiusCopyWithImpl<$Res>;
  @useResult
  $Res call({double value});
}

/// @nodoc
class __$$_UpdateRadiusCopyWithImpl<$Res>
    extends _$ShadowEventCopyWithImpl<$Res, _$_UpdateRadius>
    implements _$$_UpdateRadiusCopyWith<$Res> {
  __$$_UpdateRadiusCopyWithImpl(
      _$_UpdateRadius _value, $Res Function(_$_UpdateRadius) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_UpdateRadius(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_UpdateRadius with DiagnosticableTreeMixin implements _UpdateRadius {
  const _$_UpdateRadius(this.value);

  @override
  final double value;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ShadowEvent.updateSpread(value: $value)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ShadowEvent.updateSpread'))
      ..add(DiagnosticsProperty('value', value));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateRadius &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpdateRadiusCopyWith<_$_UpdateRadius> get copyWith =>
      __$$_UpdateRadiusCopyWithImpl<_$_UpdateRadius>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(double value) updateOffsetY,
    required TResult Function(double value) updateOffsetX,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(Color value) updateAnimatedBoxColor,
    required TResult Function(Color value) updateShadowColor,
  }) {
    return updateSpread(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(double value)? updateOffsetY,
    TResult? Function(double value)? updateOffsetX,
    TResult? Function(double value)? updateBlur,
    TResult? Function(double value)? updateSpread,
    TResult? Function(Color value)? updateAnimatedBoxColor,
    TResult? Function(Color value)? updateShadowColor,
  }) {
    return updateSpread?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(double value)? updateOffsetY,
    TResult Function(double value)? updateOffsetX,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(Color value)? updateAnimatedBoxColor,
    TResult Function(Color value)? updateShadowColor,
    required TResult orElse(),
  }) {
    if (updateSpread != null) {
      return updateSpread(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UpdateOffsetY value) updateOffsetY,
    required TResult Function(_UpdateOffsetX value) updateOffsetX,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateRadius value) updateSpread,
    required TResult Function(_UpdateAnimatedBoxColor value)
        updateAnimatedBoxColor,
    required TResult Function(_UpdateShadowColor value) updateShadowColor,
  }) {
    return updateSpread(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialEvent value)? initial,
    TResult? Function(_UpdateOffsetY value)? updateOffsetY,
    TResult? Function(_UpdateOffsetX value)? updateOffsetX,
    TResult? Function(_UpdateBlur value)? updateBlur,
    TResult? Function(_UpdateRadius value)? updateSpread,
    TResult? Function(_UpdateAnimatedBoxColor value)? updateAnimatedBoxColor,
    TResult? Function(_UpdateShadowColor value)? updateShadowColor,
  }) {
    return updateSpread?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UpdateOffsetY value)? updateOffsetY,
    TResult Function(_UpdateOffsetX value)? updateOffsetX,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateRadius value)? updateSpread,
    TResult Function(_UpdateAnimatedBoxColor value)? updateAnimatedBoxColor,
    TResult Function(_UpdateShadowColor value)? updateShadowColor,
    required TResult orElse(),
  }) {
    if (updateSpread != null) {
      return updateSpread(this);
    }
    return orElse();
  }
}

abstract class _UpdateRadius implements ShadowEvent {
  const factory _UpdateRadius(final double value) = _$_UpdateRadius;

  double get value;
  @JsonKey(ignore: true)
  _$$_UpdateRadiusCopyWith<_$_UpdateRadius> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UpdateAnimatedBoxColorCopyWith<$Res> {
  factory _$$_UpdateAnimatedBoxColorCopyWith(_$_UpdateAnimatedBoxColor value,
          $Res Function(_$_UpdateAnimatedBoxColor) then) =
      __$$_UpdateAnimatedBoxColorCopyWithImpl<$Res>;
  @useResult
  $Res call({Color value});
}

/// @nodoc
class __$$_UpdateAnimatedBoxColorCopyWithImpl<$Res>
    extends _$ShadowEventCopyWithImpl<$Res, _$_UpdateAnimatedBoxColor>
    implements _$$_UpdateAnimatedBoxColorCopyWith<$Res> {
  __$$_UpdateAnimatedBoxColorCopyWithImpl(_$_UpdateAnimatedBoxColor _value,
      $Res Function(_$_UpdateAnimatedBoxColor) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_UpdateAnimatedBoxColor(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as Color,
    ));
  }
}

/// @nodoc

class _$_UpdateAnimatedBoxColor
    with DiagnosticableTreeMixin
    implements _UpdateAnimatedBoxColor {
  const _$_UpdateAnimatedBoxColor(this.value);

  @override
  final Color value;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ShadowEvent.updateAnimatedBoxColor(value: $value)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ShadowEvent.updateAnimatedBoxColor'))
      ..add(DiagnosticsProperty('value', value));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateAnimatedBoxColor &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpdateAnimatedBoxColorCopyWith<_$_UpdateAnimatedBoxColor> get copyWith =>
      __$$_UpdateAnimatedBoxColorCopyWithImpl<_$_UpdateAnimatedBoxColor>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(double value) updateOffsetY,
    required TResult Function(double value) updateOffsetX,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(Color value) updateAnimatedBoxColor,
    required TResult Function(Color value) updateShadowColor,
  }) {
    return updateAnimatedBoxColor(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(double value)? updateOffsetY,
    TResult? Function(double value)? updateOffsetX,
    TResult? Function(double value)? updateBlur,
    TResult? Function(double value)? updateSpread,
    TResult? Function(Color value)? updateAnimatedBoxColor,
    TResult? Function(Color value)? updateShadowColor,
  }) {
    return updateAnimatedBoxColor?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(double value)? updateOffsetY,
    TResult Function(double value)? updateOffsetX,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(Color value)? updateAnimatedBoxColor,
    TResult Function(Color value)? updateShadowColor,
    required TResult orElse(),
  }) {
    if (updateAnimatedBoxColor != null) {
      return updateAnimatedBoxColor(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UpdateOffsetY value) updateOffsetY,
    required TResult Function(_UpdateOffsetX value) updateOffsetX,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateRadius value) updateSpread,
    required TResult Function(_UpdateAnimatedBoxColor value)
        updateAnimatedBoxColor,
    required TResult Function(_UpdateShadowColor value) updateShadowColor,
  }) {
    return updateAnimatedBoxColor(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialEvent value)? initial,
    TResult? Function(_UpdateOffsetY value)? updateOffsetY,
    TResult? Function(_UpdateOffsetX value)? updateOffsetX,
    TResult? Function(_UpdateBlur value)? updateBlur,
    TResult? Function(_UpdateRadius value)? updateSpread,
    TResult? Function(_UpdateAnimatedBoxColor value)? updateAnimatedBoxColor,
    TResult? Function(_UpdateShadowColor value)? updateShadowColor,
  }) {
    return updateAnimatedBoxColor?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UpdateOffsetY value)? updateOffsetY,
    TResult Function(_UpdateOffsetX value)? updateOffsetX,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateRadius value)? updateSpread,
    TResult Function(_UpdateAnimatedBoxColor value)? updateAnimatedBoxColor,
    TResult Function(_UpdateShadowColor value)? updateShadowColor,
    required TResult orElse(),
  }) {
    if (updateAnimatedBoxColor != null) {
      return updateAnimatedBoxColor(this);
    }
    return orElse();
  }
}

abstract class _UpdateAnimatedBoxColor implements ShadowEvent {
  const factory _UpdateAnimatedBoxColor(final Color value) =
      _$_UpdateAnimatedBoxColor;

  Color get value;
  @JsonKey(ignore: true)
  _$$_UpdateAnimatedBoxColorCopyWith<_$_UpdateAnimatedBoxColor> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UpdateShadowColorCopyWith<$Res> {
  factory _$$_UpdateShadowColorCopyWith(_$_UpdateShadowColor value,
          $Res Function(_$_UpdateShadowColor) then) =
      __$$_UpdateShadowColorCopyWithImpl<$Res>;
  @useResult
  $Res call({Color value});
}

/// @nodoc
class __$$_UpdateShadowColorCopyWithImpl<$Res>
    extends _$ShadowEventCopyWithImpl<$Res, _$_UpdateShadowColor>
    implements _$$_UpdateShadowColorCopyWith<$Res> {
  __$$_UpdateShadowColorCopyWithImpl(
      _$_UpdateShadowColor _value, $Res Function(_$_UpdateShadowColor) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_UpdateShadowColor(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as Color,
    ));
  }
}

/// @nodoc

class _$_UpdateShadowColor
    with DiagnosticableTreeMixin
    implements _UpdateShadowColor {
  const _$_UpdateShadowColor(this.value);

  @override
  final Color value;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ShadowEvent.updateShadowColor(value: $value)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ShadowEvent.updateShadowColor'))
      ..add(DiagnosticsProperty('value', value));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateShadowColor &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpdateShadowColorCopyWith<_$_UpdateShadowColor> get copyWith =>
      __$$_UpdateShadowColorCopyWithImpl<_$_UpdateShadowColor>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(double value) updateOffsetY,
    required TResult Function(double value) updateOffsetX,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(Color value) updateAnimatedBoxColor,
    required TResult Function(Color value) updateShadowColor,
  }) {
    return updateShadowColor(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(double value)? updateOffsetY,
    TResult? Function(double value)? updateOffsetX,
    TResult? Function(double value)? updateBlur,
    TResult? Function(double value)? updateSpread,
    TResult? Function(Color value)? updateAnimatedBoxColor,
    TResult? Function(Color value)? updateShadowColor,
  }) {
    return updateShadowColor?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(double value)? updateOffsetY,
    TResult Function(double value)? updateOffsetX,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(Color value)? updateAnimatedBoxColor,
    TResult Function(Color value)? updateShadowColor,
    required TResult orElse(),
  }) {
    if (updateShadowColor != null) {
      return updateShadowColor(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UpdateOffsetY value) updateOffsetY,
    required TResult Function(_UpdateOffsetX value) updateOffsetX,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateRadius value) updateSpread,
    required TResult Function(_UpdateAnimatedBoxColor value)
        updateAnimatedBoxColor,
    required TResult Function(_UpdateShadowColor value) updateShadowColor,
  }) {
    return updateShadowColor(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialEvent value)? initial,
    TResult? Function(_UpdateOffsetY value)? updateOffsetY,
    TResult? Function(_UpdateOffsetX value)? updateOffsetX,
    TResult? Function(_UpdateBlur value)? updateBlur,
    TResult? Function(_UpdateRadius value)? updateSpread,
    TResult? Function(_UpdateAnimatedBoxColor value)? updateAnimatedBoxColor,
    TResult? Function(_UpdateShadowColor value)? updateShadowColor,
  }) {
    return updateShadowColor?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UpdateOffsetY value)? updateOffsetY,
    TResult Function(_UpdateOffsetX value)? updateOffsetX,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateRadius value)? updateSpread,
    TResult Function(_UpdateAnimatedBoxColor value)? updateAnimatedBoxColor,
    TResult Function(_UpdateShadowColor value)? updateShadowColor,
    required TResult orElse(),
  }) {
    if (updateShadowColor != null) {
      return updateShadowColor(this);
    }
    return orElse();
  }
}

abstract class _UpdateShadowColor implements ShadowEvent {
  const factory _UpdateShadowColor(final Color value) = _$_UpdateShadowColor;

  Color get value;
  @JsonKey(ignore: true)
  _$$_UpdateShadowColorCopyWith<_$_UpdateShadowColor> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ShadowState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(Offset offset, Color shadowColor,
            Color animatedBoxColor, double blurRadius, double spreadRadius)
        updateShadow,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(Offset offset, Color shadowColor, Color animatedBoxColor,
            double blurRadius, double spreadRadius)?
        updateShadow,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(Offset offset, Color shadowColor, Color animatedBoxColor,
            double blurRadius, double spreadRadius)?
        updateShadow,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialState value) initial,
    required TResult Function(_UpdateShadow value) updateShadow,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialState value)? initial,
    TResult? Function(_UpdateShadow value)? updateShadow,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialState value)? initial,
    TResult Function(_UpdateShadow value)? updateShadow,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ShadowStateCopyWith<$Res> {
  factory $ShadowStateCopyWith(
          ShadowState value, $Res Function(ShadowState) then) =
      _$ShadowStateCopyWithImpl<$Res, ShadowState>;
}

/// @nodoc
class _$ShadowStateCopyWithImpl<$Res, $Val extends ShadowState>
    implements $ShadowStateCopyWith<$Res> {
  _$ShadowStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_InitialStateCopyWith<$Res> {
  factory _$$_InitialStateCopyWith(
          _$_InitialState value, $Res Function(_$_InitialState) then) =
      __$$_InitialStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_InitialStateCopyWithImpl<$Res>
    extends _$ShadowStateCopyWithImpl<$Res, _$_InitialState>
    implements _$$_InitialStateCopyWith<$Res> {
  __$$_InitialStateCopyWithImpl(
      _$_InitialState _value, $Res Function(_$_InitialState) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_InitialState with DiagnosticableTreeMixin implements _InitialState {
  const _$_InitialState();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ShadowState.initial()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'ShadowState.initial'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_InitialState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(Offset offset, Color shadowColor,
            Color animatedBoxColor, double blurRadius, double spreadRadius)
        updateShadow,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(Offset offset, Color shadowColor, Color animatedBoxColor,
            double blurRadius, double spreadRadius)?
        updateShadow,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(Offset offset, Color shadowColor, Color animatedBoxColor,
            double blurRadius, double spreadRadius)?
        updateShadow,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialState value) initial,
    required TResult Function(_UpdateShadow value) updateShadow,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialState value)? initial,
    TResult? Function(_UpdateShadow value)? updateShadow,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialState value)? initial,
    TResult Function(_UpdateShadow value)? updateShadow,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _InitialState implements ShadowState {
  const factory _InitialState() = _$_InitialState;
}

/// @nodoc
abstract class _$$_UpdateShadowCopyWith<$Res> {
  factory _$$_UpdateShadowCopyWith(
          _$_UpdateShadow value, $Res Function(_$_UpdateShadow) then) =
      __$$_UpdateShadowCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {Offset offset,
      Color shadowColor,
      Color animatedBoxColor,
      double blurRadius,
      double spreadRadius});
}

/// @nodoc
class __$$_UpdateShadowCopyWithImpl<$Res>
    extends _$ShadowStateCopyWithImpl<$Res, _$_UpdateShadow>
    implements _$$_UpdateShadowCopyWith<$Res> {
  __$$_UpdateShadowCopyWithImpl(
      _$_UpdateShadow _value, $Res Function(_$_UpdateShadow) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? shadowColor = null,
    Object? animatedBoxColor = null,
    Object? blurRadius = null,
    Object? spreadRadius = null,
  }) {
    return _then(_$_UpdateShadow(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as Offset,
      shadowColor: null == shadowColor
          ? _value.shadowColor
          : shadowColor // ignore: cast_nullable_to_non_nullable
              as Color,
      animatedBoxColor: null == animatedBoxColor
          ? _value.animatedBoxColor
          : animatedBoxColor // ignore: cast_nullable_to_non_nullable
              as Color,
      blurRadius: null == blurRadius
          ? _value.blurRadius
          : blurRadius // ignore: cast_nullable_to_non_nullable
              as double,
      spreadRadius: null == spreadRadius
          ? _value.spreadRadius
          : spreadRadius // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_UpdateShadow with DiagnosticableTreeMixin implements _UpdateShadow {
  const _$_UpdateShadow(
      {required this.offset,
      required this.shadowColor,
      required this.animatedBoxColor,
      required this.blurRadius,
      required this.spreadRadius});

  @override
  final Offset offset;
  @override
  final Color shadowColor;
  @override
  final Color animatedBoxColor;
  @override
  final double blurRadius;
  @override
  final double spreadRadius;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ShadowState.updateShadow(offset: $offset, shadowColor: $shadowColor, animatedBoxColor: $animatedBoxColor, blurRadius: $blurRadius, spreadRadius: $spreadRadius)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ShadowState.updateShadow'))
      ..add(DiagnosticsProperty('offset', offset))
      ..add(DiagnosticsProperty('shadowColor', shadowColor))
      ..add(DiagnosticsProperty('animatedBoxColor', animatedBoxColor))
      ..add(DiagnosticsProperty('blurRadius', blurRadius))
      ..add(DiagnosticsProperty('spreadRadius', spreadRadius));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateShadow &&
            const DeepCollectionEquality().equals(other.offset, offset) &&
            const DeepCollectionEquality()
                .equals(other.shadowColor, shadowColor) &&
            const DeepCollectionEquality()
                .equals(other.animatedBoxColor, animatedBoxColor) &&
            (identical(other.blurRadius, blurRadius) ||
                other.blurRadius == blurRadius) &&
            (identical(other.spreadRadius, spreadRadius) ||
                other.spreadRadius == spreadRadius));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(offset),
      const DeepCollectionEquality().hash(shadowColor),
      const DeepCollectionEquality().hash(animatedBoxColor),
      blurRadius,
      spreadRadius);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpdateShadowCopyWith<_$_UpdateShadow> get copyWith =>
      __$$_UpdateShadowCopyWithImpl<_$_UpdateShadow>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(Offset offset, Color shadowColor,
            Color animatedBoxColor, double blurRadius, double spreadRadius)
        updateShadow,
  }) {
    return updateShadow(
        offset, shadowColor, animatedBoxColor, blurRadius, spreadRadius);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(Offset offset, Color shadowColor, Color animatedBoxColor,
            double blurRadius, double spreadRadius)?
        updateShadow,
  }) {
    return updateShadow?.call(
        offset, shadowColor, animatedBoxColor, blurRadius, spreadRadius);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(Offset offset, Color shadowColor, Color animatedBoxColor,
            double blurRadius, double spreadRadius)?
        updateShadow,
    required TResult orElse(),
  }) {
    if (updateShadow != null) {
      return updateShadow(
          offset, shadowColor, animatedBoxColor, blurRadius, spreadRadius);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialState value) initial,
    required TResult Function(_UpdateShadow value) updateShadow,
  }) {
    return updateShadow(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialState value)? initial,
    TResult? Function(_UpdateShadow value)? updateShadow,
  }) {
    return updateShadow?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialState value)? initial,
    TResult Function(_UpdateShadow value)? updateShadow,
    required TResult orElse(),
  }) {
    if (updateShadow != null) {
      return updateShadow(this);
    }
    return orElse();
  }
}

abstract class _UpdateShadow implements ShadowState {
  const factory _UpdateShadow(
      {required final Offset offset,
      required final Color shadowColor,
      required final Color animatedBoxColor,
      required final double blurRadius,
      required final double spreadRadius}) = _$_UpdateShadow;

  Offset get offset;
  Color get shadowColor;
  Color get animatedBoxColor;
  double get blurRadius;
  double get spreadRadius;
  @JsonKey(ignore: true)
  _$$_UpdateShadowCopyWith<_$_UpdateShadow> get copyWith =>
      throw _privateConstructorUsedError;
}
