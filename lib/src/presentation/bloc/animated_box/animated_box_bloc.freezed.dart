// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'animated_box_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AnimatedBoxEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() undoChanges,
    required TResult Function(double? x, double? y) updateOffset,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(Color? animatedBoxColor, Color? shadowColor)
        updateColor,
    required TResult Function(double? topLeft, double? topRight,
            double? bottomLeft, double? bottomRight)
        updateRadius,
    required TResult Function(double? height, double? width) updateBoxSize,
    required TResult Function(int value) changeGradientState,
    required TResult Function(bool? add, bool? remove) addOrRemoveGradientColor,
    required TResult Function(int id, Color? color, double? value)
        updateGradientValueColor,
    required TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)
        updateLinearGradientValue,
    required TResult Function(GradientDirectionModel centerRadiusGradient)
        updateGradientCenterValue,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? undoChanges,
    TResult? Function(double? x, double? y)? updateOffset,
    TResult? Function(double value)? updateBlur,
    TResult? Function(double value)? updateSpread,
    TResult? Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult? Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult? Function(double? height, double? width)? updateBoxSize,
    TResult? Function(int value)? changeGradientState,
    TResult? Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult? Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult? Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult? Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? undoChanges,
    TResult Function(double? x, double? y)? updateOffset,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult Function(double? height, double? width)? updateBoxSize,
    TResult Function(int value)? changeGradientState,
    TResult Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UndoChanges value) undoChanges,
    required TResult Function(_UpdateOffset value) updateOffset,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateSpread value) updateSpread,
    required TResult Function(_UpdateColor value) updateColor,
    required TResult Function(_UpdateRadius value) updateRadius,
    required TResult Function(_UpdateBoxSize value) updateBoxSize,
    required TResult Function(_ChangeGradientState value) changeGradientState,
    required TResult Function(_AddOrRemoveGradientColor value)
        addOrRemoveGradientColor,
    required TResult Function(_UpdateGradientValueColor value)
        updateGradientValueColor,
    required TResult Function(_UpdateLinearGradientValue value)
        updateLinearGradientValue,
    required TResult Function(_UpdateGradientCenterValue value)
        updateGradientCenterValue,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialEvent value)? initial,
    TResult? Function(_UndoChanges value)? undoChanges,
    TResult? Function(_UpdateOffset value)? updateOffset,
    TResult? Function(_UpdateBlur value)? updateBlur,
    TResult? Function(_UpdateSpread value)? updateSpread,
    TResult? Function(_UpdateColor value)? updateColor,
    TResult? Function(_UpdateRadius value)? updateRadius,
    TResult? Function(_UpdateBoxSize value)? updateBoxSize,
    TResult? Function(_ChangeGradientState value)? changeGradientState,
    TResult? Function(_AddOrRemoveGradientColor value)?
        addOrRemoveGradientColor,
    TResult? Function(_UpdateGradientValueColor value)?
        updateGradientValueColor,
    TResult? Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult? Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UndoChanges value)? undoChanges,
    TResult Function(_UpdateOffset value)? updateOffset,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateSpread value)? updateSpread,
    TResult Function(_UpdateColor value)? updateColor,
    TResult Function(_UpdateRadius value)? updateRadius,
    TResult Function(_UpdateBoxSize value)? updateBoxSize,
    TResult Function(_ChangeGradientState value)? changeGradientState,
    TResult Function(_AddOrRemoveGradientColor value)? addOrRemoveGradientColor,
    TResult Function(_UpdateGradientValueColor value)? updateGradientValueColor,
    TResult Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnimatedBoxEventCopyWith<$Res> {
  factory $AnimatedBoxEventCopyWith(
          AnimatedBoxEvent value, $Res Function(AnimatedBoxEvent) then) =
      _$AnimatedBoxEventCopyWithImpl<$Res, AnimatedBoxEvent>;
}

/// @nodoc
class _$AnimatedBoxEventCopyWithImpl<$Res, $Val extends AnimatedBoxEvent>
    implements $AnimatedBoxEventCopyWith<$Res> {
  _$AnimatedBoxEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_InitialEventCopyWith<$Res> {
  factory _$$_InitialEventCopyWith(
          _$_InitialEvent value, $Res Function(_$_InitialEvent) then) =
      __$$_InitialEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_InitialEventCopyWithImpl<$Res>
    extends _$AnimatedBoxEventCopyWithImpl<$Res, _$_InitialEvent>
    implements _$$_InitialEventCopyWith<$Res> {
  __$$_InitialEventCopyWithImpl(
      _$_InitialEvent _value, $Res Function(_$_InitialEvent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_InitialEvent implements _InitialEvent {
  const _$_InitialEvent();

  @override
  String toString() {
    return 'AnimatedBoxEvent.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_InitialEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() undoChanges,
    required TResult Function(double? x, double? y) updateOffset,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(Color? animatedBoxColor, Color? shadowColor)
        updateColor,
    required TResult Function(double? topLeft, double? topRight,
            double? bottomLeft, double? bottomRight)
        updateRadius,
    required TResult Function(double? height, double? width) updateBoxSize,
    required TResult Function(int value) changeGradientState,
    required TResult Function(bool? add, bool? remove) addOrRemoveGradientColor,
    required TResult Function(int id, Color? color, double? value)
        updateGradientValueColor,
    required TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)
        updateLinearGradientValue,
    required TResult Function(GradientDirectionModel centerRadiusGradient)
        updateGradientCenterValue,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? undoChanges,
    TResult? Function(double? x, double? y)? updateOffset,
    TResult? Function(double value)? updateBlur,
    TResult? Function(double value)? updateSpread,
    TResult? Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult? Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult? Function(double? height, double? width)? updateBoxSize,
    TResult? Function(int value)? changeGradientState,
    TResult? Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult? Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult? Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult? Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? undoChanges,
    TResult Function(double? x, double? y)? updateOffset,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult Function(double? height, double? width)? updateBoxSize,
    TResult Function(int value)? changeGradientState,
    TResult Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UndoChanges value) undoChanges,
    required TResult Function(_UpdateOffset value) updateOffset,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateSpread value) updateSpread,
    required TResult Function(_UpdateColor value) updateColor,
    required TResult Function(_UpdateRadius value) updateRadius,
    required TResult Function(_UpdateBoxSize value) updateBoxSize,
    required TResult Function(_ChangeGradientState value) changeGradientState,
    required TResult Function(_AddOrRemoveGradientColor value)
        addOrRemoveGradientColor,
    required TResult Function(_UpdateGradientValueColor value)
        updateGradientValueColor,
    required TResult Function(_UpdateLinearGradientValue value)
        updateLinearGradientValue,
    required TResult Function(_UpdateGradientCenterValue value)
        updateGradientCenterValue,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialEvent value)? initial,
    TResult? Function(_UndoChanges value)? undoChanges,
    TResult? Function(_UpdateOffset value)? updateOffset,
    TResult? Function(_UpdateBlur value)? updateBlur,
    TResult? Function(_UpdateSpread value)? updateSpread,
    TResult? Function(_UpdateColor value)? updateColor,
    TResult? Function(_UpdateRadius value)? updateRadius,
    TResult? Function(_UpdateBoxSize value)? updateBoxSize,
    TResult? Function(_ChangeGradientState value)? changeGradientState,
    TResult? Function(_AddOrRemoveGradientColor value)?
        addOrRemoveGradientColor,
    TResult? Function(_UpdateGradientValueColor value)?
        updateGradientValueColor,
    TResult? Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult? Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UndoChanges value)? undoChanges,
    TResult Function(_UpdateOffset value)? updateOffset,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateSpread value)? updateSpread,
    TResult Function(_UpdateColor value)? updateColor,
    TResult Function(_UpdateRadius value)? updateRadius,
    TResult Function(_UpdateBoxSize value)? updateBoxSize,
    TResult Function(_ChangeGradientState value)? changeGradientState,
    TResult Function(_AddOrRemoveGradientColor value)? addOrRemoveGradientColor,
    TResult Function(_UpdateGradientValueColor value)? updateGradientValueColor,
    TResult Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _InitialEvent implements AnimatedBoxEvent {
  const factory _InitialEvent() = _$_InitialEvent;
}

/// @nodoc
abstract class _$$_UndoChangesCopyWith<$Res> {
  factory _$$_UndoChangesCopyWith(
          _$_UndoChanges value, $Res Function(_$_UndoChanges) then) =
      __$$_UndoChangesCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_UndoChangesCopyWithImpl<$Res>
    extends _$AnimatedBoxEventCopyWithImpl<$Res, _$_UndoChanges>
    implements _$$_UndoChangesCopyWith<$Res> {
  __$$_UndoChangesCopyWithImpl(
      _$_UndoChanges _value, $Res Function(_$_UndoChanges) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_UndoChanges implements _UndoChanges {
  const _$_UndoChanges();

  @override
  String toString() {
    return 'AnimatedBoxEvent.undoChanges()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_UndoChanges);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() undoChanges,
    required TResult Function(double? x, double? y) updateOffset,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(Color? animatedBoxColor, Color? shadowColor)
        updateColor,
    required TResult Function(double? topLeft, double? topRight,
            double? bottomLeft, double? bottomRight)
        updateRadius,
    required TResult Function(double? height, double? width) updateBoxSize,
    required TResult Function(int value) changeGradientState,
    required TResult Function(bool? add, bool? remove) addOrRemoveGradientColor,
    required TResult Function(int id, Color? color, double? value)
        updateGradientValueColor,
    required TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)
        updateLinearGradientValue,
    required TResult Function(GradientDirectionModel centerRadiusGradient)
        updateGradientCenterValue,
  }) {
    return undoChanges();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? undoChanges,
    TResult? Function(double? x, double? y)? updateOffset,
    TResult? Function(double value)? updateBlur,
    TResult? Function(double value)? updateSpread,
    TResult? Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult? Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult? Function(double? height, double? width)? updateBoxSize,
    TResult? Function(int value)? changeGradientState,
    TResult? Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult? Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult? Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult? Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
  }) {
    return undoChanges?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? undoChanges,
    TResult Function(double? x, double? y)? updateOffset,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult Function(double? height, double? width)? updateBoxSize,
    TResult Function(int value)? changeGradientState,
    TResult Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) {
    if (undoChanges != null) {
      return undoChanges();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UndoChanges value) undoChanges,
    required TResult Function(_UpdateOffset value) updateOffset,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateSpread value) updateSpread,
    required TResult Function(_UpdateColor value) updateColor,
    required TResult Function(_UpdateRadius value) updateRadius,
    required TResult Function(_UpdateBoxSize value) updateBoxSize,
    required TResult Function(_ChangeGradientState value) changeGradientState,
    required TResult Function(_AddOrRemoveGradientColor value)
        addOrRemoveGradientColor,
    required TResult Function(_UpdateGradientValueColor value)
        updateGradientValueColor,
    required TResult Function(_UpdateLinearGradientValue value)
        updateLinearGradientValue,
    required TResult Function(_UpdateGradientCenterValue value)
        updateGradientCenterValue,
  }) {
    return undoChanges(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialEvent value)? initial,
    TResult? Function(_UndoChanges value)? undoChanges,
    TResult? Function(_UpdateOffset value)? updateOffset,
    TResult? Function(_UpdateBlur value)? updateBlur,
    TResult? Function(_UpdateSpread value)? updateSpread,
    TResult? Function(_UpdateColor value)? updateColor,
    TResult? Function(_UpdateRadius value)? updateRadius,
    TResult? Function(_UpdateBoxSize value)? updateBoxSize,
    TResult? Function(_ChangeGradientState value)? changeGradientState,
    TResult? Function(_AddOrRemoveGradientColor value)?
        addOrRemoveGradientColor,
    TResult? Function(_UpdateGradientValueColor value)?
        updateGradientValueColor,
    TResult? Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult? Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
  }) {
    return undoChanges?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UndoChanges value)? undoChanges,
    TResult Function(_UpdateOffset value)? updateOffset,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateSpread value)? updateSpread,
    TResult Function(_UpdateColor value)? updateColor,
    TResult Function(_UpdateRadius value)? updateRadius,
    TResult Function(_UpdateBoxSize value)? updateBoxSize,
    TResult Function(_ChangeGradientState value)? changeGradientState,
    TResult Function(_AddOrRemoveGradientColor value)? addOrRemoveGradientColor,
    TResult Function(_UpdateGradientValueColor value)? updateGradientValueColor,
    TResult Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) {
    if (undoChanges != null) {
      return undoChanges(this);
    }
    return orElse();
  }
}

abstract class _UndoChanges implements AnimatedBoxEvent {
  const factory _UndoChanges() = _$_UndoChanges;
}

/// @nodoc
abstract class _$$_UpdateOffsetCopyWith<$Res> {
  factory _$$_UpdateOffsetCopyWith(
          _$_UpdateOffset value, $Res Function(_$_UpdateOffset) then) =
      __$$_UpdateOffsetCopyWithImpl<$Res>;
  @useResult
  $Res call({double? x, double? y});
}

/// @nodoc
class __$$_UpdateOffsetCopyWithImpl<$Res>
    extends _$AnimatedBoxEventCopyWithImpl<$Res, _$_UpdateOffset>
    implements _$$_UpdateOffsetCopyWith<$Res> {
  __$$_UpdateOffsetCopyWithImpl(
      _$_UpdateOffset _value, $Res Function(_$_UpdateOffset) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? x = freezed,
    Object? y = freezed,
  }) {
    return _then(_$_UpdateOffset(
      x: freezed == x
          ? _value.x
          : x // ignore: cast_nullable_to_non_nullable
              as double?,
      y: freezed == y
          ? _value.y
          : y // ignore: cast_nullable_to_non_nullable
              as double?,
    ));
  }
}

/// @nodoc

class _$_UpdateOffset implements _UpdateOffset {
  const _$_UpdateOffset({this.x, this.y});

  @override
  final double? x;
  @override
  final double? y;

  @override
  String toString() {
    return 'AnimatedBoxEvent.updateOffset(x: $x, y: $y)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateOffset &&
            (identical(other.x, x) || other.x == x) &&
            (identical(other.y, y) || other.y == y));
  }

  @override
  int get hashCode => Object.hash(runtimeType, x, y);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpdateOffsetCopyWith<_$_UpdateOffset> get copyWith =>
      __$$_UpdateOffsetCopyWithImpl<_$_UpdateOffset>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() undoChanges,
    required TResult Function(double? x, double? y) updateOffset,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(Color? animatedBoxColor, Color? shadowColor)
        updateColor,
    required TResult Function(double? topLeft, double? topRight,
            double? bottomLeft, double? bottomRight)
        updateRadius,
    required TResult Function(double? height, double? width) updateBoxSize,
    required TResult Function(int value) changeGradientState,
    required TResult Function(bool? add, bool? remove) addOrRemoveGradientColor,
    required TResult Function(int id, Color? color, double? value)
        updateGradientValueColor,
    required TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)
        updateLinearGradientValue,
    required TResult Function(GradientDirectionModel centerRadiusGradient)
        updateGradientCenterValue,
  }) {
    return updateOffset(x, y);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? undoChanges,
    TResult? Function(double? x, double? y)? updateOffset,
    TResult? Function(double value)? updateBlur,
    TResult? Function(double value)? updateSpread,
    TResult? Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult? Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult? Function(double? height, double? width)? updateBoxSize,
    TResult? Function(int value)? changeGradientState,
    TResult? Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult? Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult? Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult? Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
  }) {
    return updateOffset?.call(x, y);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? undoChanges,
    TResult Function(double? x, double? y)? updateOffset,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult Function(double? height, double? width)? updateBoxSize,
    TResult Function(int value)? changeGradientState,
    TResult Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) {
    if (updateOffset != null) {
      return updateOffset(x, y);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UndoChanges value) undoChanges,
    required TResult Function(_UpdateOffset value) updateOffset,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateSpread value) updateSpread,
    required TResult Function(_UpdateColor value) updateColor,
    required TResult Function(_UpdateRadius value) updateRadius,
    required TResult Function(_UpdateBoxSize value) updateBoxSize,
    required TResult Function(_ChangeGradientState value) changeGradientState,
    required TResult Function(_AddOrRemoveGradientColor value)
        addOrRemoveGradientColor,
    required TResult Function(_UpdateGradientValueColor value)
        updateGradientValueColor,
    required TResult Function(_UpdateLinearGradientValue value)
        updateLinearGradientValue,
    required TResult Function(_UpdateGradientCenterValue value)
        updateGradientCenterValue,
  }) {
    return updateOffset(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialEvent value)? initial,
    TResult? Function(_UndoChanges value)? undoChanges,
    TResult? Function(_UpdateOffset value)? updateOffset,
    TResult? Function(_UpdateBlur value)? updateBlur,
    TResult? Function(_UpdateSpread value)? updateSpread,
    TResult? Function(_UpdateColor value)? updateColor,
    TResult? Function(_UpdateRadius value)? updateRadius,
    TResult? Function(_UpdateBoxSize value)? updateBoxSize,
    TResult? Function(_ChangeGradientState value)? changeGradientState,
    TResult? Function(_AddOrRemoveGradientColor value)?
        addOrRemoveGradientColor,
    TResult? Function(_UpdateGradientValueColor value)?
        updateGradientValueColor,
    TResult? Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult? Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
  }) {
    return updateOffset?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UndoChanges value)? undoChanges,
    TResult Function(_UpdateOffset value)? updateOffset,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateSpread value)? updateSpread,
    TResult Function(_UpdateColor value)? updateColor,
    TResult Function(_UpdateRadius value)? updateRadius,
    TResult Function(_UpdateBoxSize value)? updateBoxSize,
    TResult Function(_ChangeGradientState value)? changeGradientState,
    TResult Function(_AddOrRemoveGradientColor value)? addOrRemoveGradientColor,
    TResult Function(_UpdateGradientValueColor value)? updateGradientValueColor,
    TResult Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) {
    if (updateOffset != null) {
      return updateOffset(this);
    }
    return orElse();
  }
}

abstract class _UpdateOffset implements AnimatedBoxEvent {
  const factory _UpdateOffset({final double? x, final double? y}) =
      _$_UpdateOffset;

  double? get x;
  double? get y;
  @JsonKey(ignore: true)
  _$$_UpdateOffsetCopyWith<_$_UpdateOffset> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UpdateBlurCopyWith<$Res> {
  factory _$$_UpdateBlurCopyWith(
          _$_UpdateBlur value, $Res Function(_$_UpdateBlur) then) =
      __$$_UpdateBlurCopyWithImpl<$Res>;
  @useResult
  $Res call({double value});
}

/// @nodoc
class __$$_UpdateBlurCopyWithImpl<$Res>
    extends _$AnimatedBoxEventCopyWithImpl<$Res, _$_UpdateBlur>
    implements _$$_UpdateBlurCopyWith<$Res> {
  __$$_UpdateBlurCopyWithImpl(
      _$_UpdateBlur _value, $Res Function(_$_UpdateBlur) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_UpdateBlur(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_UpdateBlur implements _UpdateBlur {
  const _$_UpdateBlur(this.value);

  @override
  final double value;

  @override
  String toString() {
    return 'AnimatedBoxEvent.updateBlur(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateBlur &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpdateBlurCopyWith<_$_UpdateBlur> get copyWith =>
      __$$_UpdateBlurCopyWithImpl<_$_UpdateBlur>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() undoChanges,
    required TResult Function(double? x, double? y) updateOffset,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(Color? animatedBoxColor, Color? shadowColor)
        updateColor,
    required TResult Function(double? topLeft, double? topRight,
            double? bottomLeft, double? bottomRight)
        updateRadius,
    required TResult Function(double? height, double? width) updateBoxSize,
    required TResult Function(int value) changeGradientState,
    required TResult Function(bool? add, bool? remove) addOrRemoveGradientColor,
    required TResult Function(int id, Color? color, double? value)
        updateGradientValueColor,
    required TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)
        updateLinearGradientValue,
    required TResult Function(GradientDirectionModel centerRadiusGradient)
        updateGradientCenterValue,
  }) {
    return updateBlur(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? undoChanges,
    TResult? Function(double? x, double? y)? updateOffset,
    TResult? Function(double value)? updateBlur,
    TResult? Function(double value)? updateSpread,
    TResult? Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult? Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult? Function(double? height, double? width)? updateBoxSize,
    TResult? Function(int value)? changeGradientState,
    TResult? Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult? Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult? Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult? Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
  }) {
    return updateBlur?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? undoChanges,
    TResult Function(double? x, double? y)? updateOffset,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult Function(double? height, double? width)? updateBoxSize,
    TResult Function(int value)? changeGradientState,
    TResult Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) {
    if (updateBlur != null) {
      return updateBlur(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UndoChanges value) undoChanges,
    required TResult Function(_UpdateOffset value) updateOffset,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateSpread value) updateSpread,
    required TResult Function(_UpdateColor value) updateColor,
    required TResult Function(_UpdateRadius value) updateRadius,
    required TResult Function(_UpdateBoxSize value) updateBoxSize,
    required TResult Function(_ChangeGradientState value) changeGradientState,
    required TResult Function(_AddOrRemoveGradientColor value)
        addOrRemoveGradientColor,
    required TResult Function(_UpdateGradientValueColor value)
        updateGradientValueColor,
    required TResult Function(_UpdateLinearGradientValue value)
        updateLinearGradientValue,
    required TResult Function(_UpdateGradientCenterValue value)
        updateGradientCenterValue,
  }) {
    return updateBlur(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialEvent value)? initial,
    TResult? Function(_UndoChanges value)? undoChanges,
    TResult? Function(_UpdateOffset value)? updateOffset,
    TResult? Function(_UpdateBlur value)? updateBlur,
    TResult? Function(_UpdateSpread value)? updateSpread,
    TResult? Function(_UpdateColor value)? updateColor,
    TResult? Function(_UpdateRadius value)? updateRadius,
    TResult? Function(_UpdateBoxSize value)? updateBoxSize,
    TResult? Function(_ChangeGradientState value)? changeGradientState,
    TResult? Function(_AddOrRemoveGradientColor value)?
        addOrRemoveGradientColor,
    TResult? Function(_UpdateGradientValueColor value)?
        updateGradientValueColor,
    TResult? Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult? Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
  }) {
    return updateBlur?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UndoChanges value)? undoChanges,
    TResult Function(_UpdateOffset value)? updateOffset,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateSpread value)? updateSpread,
    TResult Function(_UpdateColor value)? updateColor,
    TResult Function(_UpdateRadius value)? updateRadius,
    TResult Function(_UpdateBoxSize value)? updateBoxSize,
    TResult Function(_ChangeGradientState value)? changeGradientState,
    TResult Function(_AddOrRemoveGradientColor value)? addOrRemoveGradientColor,
    TResult Function(_UpdateGradientValueColor value)? updateGradientValueColor,
    TResult Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) {
    if (updateBlur != null) {
      return updateBlur(this);
    }
    return orElse();
  }
}

abstract class _UpdateBlur implements AnimatedBoxEvent {
  const factory _UpdateBlur(final double value) = _$_UpdateBlur;

  double get value;
  @JsonKey(ignore: true)
  _$$_UpdateBlurCopyWith<_$_UpdateBlur> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UpdateSpreadCopyWith<$Res> {
  factory _$$_UpdateSpreadCopyWith(
          _$_UpdateSpread value, $Res Function(_$_UpdateSpread) then) =
      __$$_UpdateSpreadCopyWithImpl<$Res>;
  @useResult
  $Res call({double value});
}

/// @nodoc
class __$$_UpdateSpreadCopyWithImpl<$Res>
    extends _$AnimatedBoxEventCopyWithImpl<$Res, _$_UpdateSpread>
    implements _$$_UpdateSpreadCopyWith<$Res> {
  __$$_UpdateSpreadCopyWithImpl(
      _$_UpdateSpread _value, $Res Function(_$_UpdateSpread) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_UpdateSpread(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_UpdateSpread implements _UpdateSpread {
  const _$_UpdateSpread(this.value);

  @override
  final double value;

  @override
  String toString() {
    return 'AnimatedBoxEvent.updateSpread(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateSpread &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpdateSpreadCopyWith<_$_UpdateSpread> get copyWith =>
      __$$_UpdateSpreadCopyWithImpl<_$_UpdateSpread>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() undoChanges,
    required TResult Function(double? x, double? y) updateOffset,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(Color? animatedBoxColor, Color? shadowColor)
        updateColor,
    required TResult Function(double? topLeft, double? topRight,
            double? bottomLeft, double? bottomRight)
        updateRadius,
    required TResult Function(double? height, double? width) updateBoxSize,
    required TResult Function(int value) changeGradientState,
    required TResult Function(bool? add, bool? remove) addOrRemoveGradientColor,
    required TResult Function(int id, Color? color, double? value)
        updateGradientValueColor,
    required TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)
        updateLinearGradientValue,
    required TResult Function(GradientDirectionModel centerRadiusGradient)
        updateGradientCenterValue,
  }) {
    return updateSpread(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? undoChanges,
    TResult? Function(double? x, double? y)? updateOffset,
    TResult? Function(double value)? updateBlur,
    TResult? Function(double value)? updateSpread,
    TResult? Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult? Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult? Function(double? height, double? width)? updateBoxSize,
    TResult? Function(int value)? changeGradientState,
    TResult? Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult? Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult? Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult? Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
  }) {
    return updateSpread?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? undoChanges,
    TResult Function(double? x, double? y)? updateOffset,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult Function(double? height, double? width)? updateBoxSize,
    TResult Function(int value)? changeGradientState,
    TResult Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) {
    if (updateSpread != null) {
      return updateSpread(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UndoChanges value) undoChanges,
    required TResult Function(_UpdateOffset value) updateOffset,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateSpread value) updateSpread,
    required TResult Function(_UpdateColor value) updateColor,
    required TResult Function(_UpdateRadius value) updateRadius,
    required TResult Function(_UpdateBoxSize value) updateBoxSize,
    required TResult Function(_ChangeGradientState value) changeGradientState,
    required TResult Function(_AddOrRemoveGradientColor value)
        addOrRemoveGradientColor,
    required TResult Function(_UpdateGradientValueColor value)
        updateGradientValueColor,
    required TResult Function(_UpdateLinearGradientValue value)
        updateLinearGradientValue,
    required TResult Function(_UpdateGradientCenterValue value)
        updateGradientCenterValue,
  }) {
    return updateSpread(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialEvent value)? initial,
    TResult? Function(_UndoChanges value)? undoChanges,
    TResult? Function(_UpdateOffset value)? updateOffset,
    TResult? Function(_UpdateBlur value)? updateBlur,
    TResult? Function(_UpdateSpread value)? updateSpread,
    TResult? Function(_UpdateColor value)? updateColor,
    TResult? Function(_UpdateRadius value)? updateRadius,
    TResult? Function(_UpdateBoxSize value)? updateBoxSize,
    TResult? Function(_ChangeGradientState value)? changeGradientState,
    TResult? Function(_AddOrRemoveGradientColor value)?
        addOrRemoveGradientColor,
    TResult? Function(_UpdateGradientValueColor value)?
        updateGradientValueColor,
    TResult? Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult? Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
  }) {
    return updateSpread?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UndoChanges value)? undoChanges,
    TResult Function(_UpdateOffset value)? updateOffset,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateSpread value)? updateSpread,
    TResult Function(_UpdateColor value)? updateColor,
    TResult Function(_UpdateRadius value)? updateRadius,
    TResult Function(_UpdateBoxSize value)? updateBoxSize,
    TResult Function(_ChangeGradientState value)? changeGradientState,
    TResult Function(_AddOrRemoveGradientColor value)? addOrRemoveGradientColor,
    TResult Function(_UpdateGradientValueColor value)? updateGradientValueColor,
    TResult Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) {
    if (updateSpread != null) {
      return updateSpread(this);
    }
    return orElse();
  }
}

abstract class _UpdateSpread implements AnimatedBoxEvent {
  const factory _UpdateSpread(final double value) = _$_UpdateSpread;

  double get value;
  @JsonKey(ignore: true)
  _$$_UpdateSpreadCopyWith<_$_UpdateSpread> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UpdateColorCopyWith<$Res> {
  factory _$$_UpdateColorCopyWith(
          _$_UpdateColor value, $Res Function(_$_UpdateColor) then) =
      __$$_UpdateColorCopyWithImpl<$Res>;
  @useResult
  $Res call({Color? animatedBoxColor, Color? shadowColor});
}

/// @nodoc
class __$$_UpdateColorCopyWithImpl<$Res>
    extends _$AnimatedBoxEventCopyWithImpl<$Res, _$_UpdateColor>
    implements _$$_UpdateColorCopyWith<$Res> {
  __$$_UpdateColorCopyWithImpl(
      _$_UpdateColor _value, $Res Function(_$_UpdateColor) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? animatedBoxColor = freezed,
    Object? shadowColor = freezed,
  }) {
    return _then(_$_UpdateColor(
      animatedBoxColor: freezed == animatedBoxColor
          ? _value.animatedBoxColor
          : animatedBoxColor // ignore: cast_nullable_to_non_nullable
              as Color?,
      shadowColor: freezed == shadowColor
          ? _value.shadowColor
          : shadowColor // ignore: cast_nullable_to_non_nullable
              as Color?,
    ));
  }
}

/// @nodoc

class _$_UpdateColor implements _UpdateColor {
  const _$_UpdateColor({this.animatedBoxColor, this.shadowColor});

  @override
  final Color? animatedBoxColor;
  @override
  final Color? shadowColor;

  @override
  String toString() {
    return 'AnimatedBoxEvent.updateColor(animatedBoxColor: $animatedBoxColor, shadowColor: $shadowColor)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateColor &&
            (identical(other.animatedBoxColor, animatedBoxColor) ||
                other.animatedBoxColor == animatedBoxColor) &&
            (identical(other.shadowColor, shadowColor) ||
                other.shadowColor == shadowColor));
  }

  @override
  int get hashCode => Object.hash(runtimeType, animatedBoxColor, shadowColor);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpdateColorCopyWith<_$_UpdateColor> get copyWith =>
      __$$_UpdateColorCopyWithImpl<_$_UpdateColor>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() undoChanges,
    required TResult Function(double? x, double? y) updateOffset,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(Color? animatedBoxColor, Color? shadowColor)
        updateColor,
    required TResult Function(double? topLeft, double? topRight,
            double? bottomLeft, double? bottomRight)
        updateRadius,
    required TResult Function(double? height, double? width) updateBoxSize,
    required TResult Function(int value) changeGradientState,
    required TResult Function(bool? add, bool? remove) addOrRemoveGradientColor,
    required TResult Function(int id, Color? color, double? value)
        updateGradientValueColor,
    required TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)
        updateLinearGradientValue,
    required TResult Function(GradientDirectionModel centerRadiusGradient)
        updateGradientCenterValue,
  }) {
    return updateColor(animatedBoxColor, shadowColor);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? undoChanges,
    TResult? Function(double? x, double? y)? updateOffset,
    TResult? Function(double value)? updateBlur,
    TResult? Function(double value)? updateSpread,
    TResult? Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult? Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult? Function(double? height, double? width)? updateBoxSize,
    TResult? Function(int value)? changeGradientState,
    TResult? Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult? Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult? Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult? Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
  }) {
    return updateColor?.call(animatedBoxColor, shadowColor);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? undoChanges,
    TResult Function(double? x, double? y)? updateOffset,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult Function(double? height, double? width)? updateBoxSize,
    TResult Function(int value)? changeGradientState,
    TResult Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) {
    if (updateColor != null) {
      return updateColor(animatedBoxColor, shadowColor);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UndoChanges value) undoChanges,
    required TResult Function(_UpdateOffset value) updateOffset,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateSpread value) updateSpread,
    required TResult Function(_UpdateColor value) updateColor,
    required TResult Function(_UpdateRadius value) updateRadius,
    required TResult Function(_UpdateBoxSize value) updateBoxSize,
    required TResult Function(_ChangeGradientState value) changeGradientState,
    required TResult Function(_AddOrRemoveGradientColor value)
        addOrRemoveGradientColor,
    required TResult Function(_UpdateGradientValueColor value)
        updateGradientValueColor,
    required TResult Function(_UpdateLinearGradientValue value)
        updateLinearGradientValue,
    required TResult Function(_UpdateGradientCenterValue value)
        updateGradientCenterValue,
  }) {
    return updateColor(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialEvent value)? initial,
    TResult? Function(_UndoChanges value)? undoChanges,
    TResult? Function(_UpdateOffset value)? updateOffset,
    TResult? Function(_UpdateBlur value)? updateBlur,
    TResult? Function(_UpdateSpread value)? updateSpread,
    TResult? Function(_UpdateColor value)? updateColor,
    TResult? Function(_UpdateRadius value)? updateRadius,
    TResult? Function(_UpdateBoxSize value)? updateBoxSize,
    TResult? Function(_ChangeGradientState value)? changeGradientState,
    TResult? Function(_AddOrRemoveGradientColor value)?
        addOrRemoveGradientColor,
    TResult? Function(_UpdateGradientValueColor value)?
        updateGradientValueColor,
    TResult? Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult? Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
  }) {
    return updateColor?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UndoChanges value)? undoChanges,
    TResult Function(_UpdateOffset value)? updateOffset,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateSpread value)? updateSpread,
    TResult Function(_UpdateColor value)? updateColor,
    TResult Function(_UpdateRadius value)? updateRadius,
    TResult Function(_UpdateBoxSize value)? updateBoxSize,
    TResult Function(_ChangeGradientState value)? changeGradientState,
    TResult Function(_AddOrRemoveGradientColor value)? addOrRemoveGradientColor,
    TResult Function(_UpdateGradientValueColor value)? updateGradientValueColor,
    TResult Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) {
    if (updateColor != null) {
      return updateColor(this);
    }
    return orElse();
  }
}

abstract class _UpdateColor implements AnimatedBoxEvent {
  const factory _UpdateColor(
      {final Color? animatedBoxColor,
      final Color? shadowColor}) = _$_UpdateColor;

  Color? get animatedBoxColor;
  Color? get shadowColor;
  @JsonKey(ignore: true)
  _$$_UpdateColorCopyWith<_$_UpdateColor> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UpdateRadiusCopyWith<$Res> {
  factory _$$_UpdateRadiusCopyWith(
          _$_UpdateRadius value, $Res Function(_$_UpdateRadius) then) =
      __$$_UpdateRadiusCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {double? topLeft,
      double? topRight,
      double? bottomLeft,
      double? bottomRight});
}

/// @nodoc
class __$$_UpdateRadiusCopyWithImpl<$Res>
    extends _$AnimatedBoxEventCopyWithImpl<$Res, _$_UpdateRadius>
    implements _$$_UpdateRadiusCopyWith<$Res> {
  __$$_UpdateRadiusCopyWithImpl(
      _$_UpdateRadius _value, $Res Function(_$_UpdateRadius) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? topLeft = freezed,
    Object? topRight = freezed,
    Object? bottomLeft = freezed,
    Object? bottomRight = freezed,
  }) {
    return _then(_$_UpdateRadius(
      topLeft: freezed == topLeft
          ? _value.topLeft
          : topLeft // ignore: cast_nullable_to_non_nullable
              as double?,
      topRight: freezed == topRight
          ? _value.topRight
          : topRight // ignore: cast_nullable_to_non_nullable
              as double?,
      bottomLeft: freezed == bottomLeft
          ? _value.bottomLeft
          : bottomLeft // ignore: cast_nullable_to_non_nullable
              as double?,
      bottomRight: freezed == bottomRight
          ? _value.bottomRight
          : bottomRight // ignore: cast_nullable_to_non_nullable
              as double?,
    ));
  }
}

/// @nodoc

class _$_UpdateRadius implements _UpdateRadius {
  const _$_UpdateRadius(
      {this.topLeft, this.topRight, this.bottomLeft, this.bottomRight});

  @override
  final double? topLeft;
  @override
  final double? topRight;
  @override
  final double? bottomLeft;
  @override
  final double? bottomRight;

  @override
  String toString() {
    return 'AnimatedBoxEvent.updateRadius(topLeft: $topLeft, topRight: $topRight, bottomLeft: $bottomLeft, bottomRight: $bottomRight)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateRadius &&
            (identical(other.topLeft, topLeft) || other.topLeft == topLeft) &&
            (identical(other.topRight, topRight) ||
                other.topRight == topRight) &&
            (identical(other.bottomLeft, bottomLeft) ||
                other.bottomLeft == bottomLeft) &&
            (identical(other.bottomRight, bottomRight) ||
                other.bottomRight == bottomRight));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, topLeft, topRight, bottomLeft, bottomRight);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpdateRadiusCopyWith<_$_UpdateRadius> get copyWith =>
      __$$_UpdateRadiusCopyWithImpl<_$_UpdateRadius>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() undoChanges,
    required TResult Function(double? x, double? y) updateOffset,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(Color? animatedBoxColor, Color? shadowColor)
        updateColor,
    required TResult Function(double? topLeft, double? topRight,
            double? bottomLeft, double? bottomRight)
        updateRadius,
    required TResult Function(double? height, double? width) updateBoxSize,
    required TResult Function(int value) changeGradientState,
    required TResult Function(bool? add, bool? remove) addOrRemoveGradientColor,
    required TResult Function(int id, Color? color, double? value)
        updateGradientValueColor,
    required TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)
        updateLinearGradientValue,
    required TResult Function(GradientDirectionModel centerRadiusGradient)
        updateGradientCenterValue,
  }) {
    return updateRadius(topLeft, topRight, bottomLeft, bottomRight);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? undoChanges,
    TResult? Function(double? x, double? y)? updateOffset,
    TResult? Function(double value)? updateBlur,
    TResult? Function(double value)? updateSpread,
    TResult? Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult? Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult? Function(double? height, double? width)? updateBoxSize,
    TResult? Function(int value)? changeGradientState,
    TResult? Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult? Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult? Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult? Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
  }) {
    return updateRadius?.call(topLeft, topRight, bottomLeft, bottomRight);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? undoChanges,
    TResult Function(double? x, double? y)? updateOffset,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult Function(double? height, double? width)? updateBoxSize,
    TResult Function(int value)? changeGradientState,
    TResult Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) {
    if (updateRadius != null) {
      return updateRadius(topLeft, topRight, bottomLeft, bottomRight);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UndoChanges value) undoChanges,
    required TResult Function(_UpdateOffset value) updateOffset,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateSpread value) updateSpread,
    required TResult Function(_UpdateColor value) updateColor,
    required TResult Function(_UpdateRadius value) updateRadius,
    required TResult Function(_UpdateBoxSize value) updateBoxSize,
    required TResult Function(_ChangeGradientState value) changeGradientState,
    required TResult Function(_AddOrRemoveGradientColor value)
        addOrRemoveGradientColor,
    required TResult Function(_UpdateGradientValueColor value)
        updateGradientValueColor,
    required TResult Function(_UpdateLinearGradientValue value)
        updateLinearGradientValue,
    required TResult Function(_UpdateGradientCenterValue value)
        updateGradientCenterValue,
  }) {
    return updateRadius(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialEvent value)? initial,
    TResult? Function(_UndoChanges value)? undoChanges,
    TResult? Function(_UpdateOffset value)? updateOffset,
    TResult? Function(_UpdateBlur value)? updateBlur,
    TResult? Function(_UpdateSpread value)? updateSpread,
    TResult? Function(_UpdateColor value)? updateColor,
    TResult? Function(_UpdateRadius value)? updateRadius,
    TResult? Function(_UpdateBoxSize value)? updateBoxSize,
    TResult? Function(_ChangeGradientState value)? changeGradientState,
    TResult? Function(_AddOrRemoveGradientColor value)?
        addOrRemoveGradientColor,
    TResult? Function(_UpdateGradientValueColor value)?
        updateGradientValueColor,
    TResult? Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult? Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
  }) {
    return updateRadius?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UndoChanges value)? undoChanges,
    TResult Function(_UpdateOffset value)? updateOffset,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateSpread value)? updateSpread,
    TResult Function(_UpdateColor value)? updateColor,
    TResult Function(_UpdateRadius value)? updateRadius,
    TResult Function(_UpdateBoxSize value)? updateBoxSize,
    TResult Function(_ChangeGradientState value)? changeGradientState,
    TResult Function(_AddOrRemoveGradientColor value)? addOrRemoveGradientColor,
    TResult Function(_UpdateGradientValueColor value)? updateGradientValueColor,
    TResult Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) {
    if (updateRadius != null) {
      return updateRadius(this);
    }
    return orElse();
  }
}

abstract class _UpdateRadius implements AnimatedBoxEvent {
  const factory _UpdateRadius(
      {final double? topLeft,
      final double? topRight,
      final double? bottomLeft,
      final double? bottomRight}) = _$_UpdateRadius;

  double? get topLeft;
  double? get topRight;
  double? get bottomLeft;
  double? get bottomRight;
  @JsonKey(ignore: true)
  _$$_UpdateRadiusCopyWith<_$_UpdateRadius> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UpdateBoxSizeCopyWith<$Res> {
  factory _$$_UpdateBoxSizeCopyWith(
          _$_UpdateBoxSize value, $Res Function(_$_UpdateBoxSize) then) =
      __$$_UpdateBoxSizeCopyWithImpl<$Res>;
  @useResult
  $Res call({double? height, double? width});
}

/// @nodoc
class __$$_UpdateBoxSizeCopyWithImpl<$Res>
    extends _$AnimatedBoxEventCopyWithImpl<$Res, _$_UpdateBoxSize>
    implements _$$_UpdateBoxSizeCopyWith<$Res> {
  __$$_UpdateBoxSizeCopyWithImpl(
      _$_UpdateBoxSize _value, $Res Function(_$_UpdateBoxSize) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? height = freezed,
    Object? width = freezed,
  }) {
    return _then(_$_UpdateBoxSize(
      height: freezed == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as double?,
      width: freezed == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as double?,
    ));
  }
}

/// @nodoc

class _$_UpdateBoxSize implements _UpdateBoxSize {
  const _$_UpdateBoxSize({this.height, this.width});

  @override
  final double? height;
  @override
  final double? width;

  @override
  String toString() {
    return 'AnimatedBoxEvent.updateBoxSize(height: $height, width: $width)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateBoxSize &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.width, width) || other.width == width));
  }

  @override
  int get hashCode => Object.hash(runtimeType, height, width);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpdateBoxSizeCopyWith<_$_UpdateBoxSize> get copyWith =>
      __$$_UpdateBoxSizeCopyWithImpl<_$_UpdateBoxSize>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() undoChanges,
    required TResult Function(double? x, double? y) updateOffset,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(Color? animatedBoxColor, Color? shadowColor)
        updateColor,
    required TResult Function(double? topLeft, double? topRight,
            double? bottomLeft, double? bottomRight)
        updateRadius,
    required TResult Function(double? height, double? width) updateBoxSize,
    required TResult Function(int value) changeGradientState,
    required TResult Function(bool? add, bool? remove) addOrRemoveGradientColor,
    required TResult Function(int id, Color? color, double? value)
        updateGradientValueColor,
    required TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)
        updateLinearGradientValue,
    required TResult Function(GradientDirectionModel centerRadiusGradient)
        updateGradientCenterValue,
  }) {
    return updateBoxSize(height, width);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? undoChanges,
    TResult? Function(double? x, double? y)? updateOffset,
    TResult? Function(double value)? updateBlur,
    TResult? Function(double value)? updateSpread,
    TResult? Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult? Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult? Function(double? height, double? width)? updateBoxSize,
    TResult? Function(int value)? changeGradientState,
    TResult? Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult? Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult? Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult? Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
  }) {
    return updateBoxSize?.call(height, width);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? undoChanges,
    TResult Function(double? x, double? y)? updateOffset,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult Function(double? height, double? width)? updateBoxSize,
    TResult Function(int value)? changeGradientState,
    TResult Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) {
    if (updateBoxSize != null) {
      return updateBoxSize(height, width);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UndoChanges value) undoChanges,
    required TResult Function(_UpdateOffset value) updateOffset,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateSpread value) updateSpread,
    required TResult Function(_UpdateColor value) updateColor,
    required TResult Function(_UpdateRadius value) updateRadius,
    required TResult Function(_UpdateBoxSize value) updateBoxSize,
    required TResult Function(_ChangeGradientState value) changeGradientState,
    required TResult Function(_AddOrRemoveGradientColor value)
        addOrRemoveGradientColor,
    required TResult Function(_UpdateGradientValueColor value)
        updateGradientValueColor,
    required TResult Function(_UpdateLinearGradientValue value)
        updateLinearGradientValue,
    required TResult Function(_UpdateGradientCenterValue value)
        updateGradientCenterValue,
  }) {
    return updateBoxSize(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialEvent value)? initial,
    TResult? Function(_UndoChanges value)? undoChanges,
    TResult? Function(_UpdateOffset value)? updateOffset,
    TResult? Function(_UpdateBlur value)? updateBlur,
    TResult? Function(_UpdateSpread value)? updateSpread,
    TResult? Function(_UpdateColor value)? updateColor,
    TResult? Function(_UpdateRadius value)? updateRadius,
    TResult? Function(_UpdateBoxSize value)? updateBoxSize,
    TResult? Function(_ChangeGradientState value)? changeGradientState,
    TResult? Function(_AddOrRemoveGradientColor value)?
        addOrRemoveGradientColor,
    TResult? Function(_UpdateGradientValueColor value)?
        updateGradientValueColor,
    TResult? Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult? Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
  }) {
    return updateBoxSize?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UndoChanges value)? undoChanges,
    TResult Function(_UpdateOffset value)? updateOffset,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateSpread value)? updateSpread,
    TResult Function(_UpdateColor value)? updateColor,
    TResult Function(_UpdateRadius value)? updateRadius,
    TResult Function(_UpdateBoxSize value)? updateBoxSize,
    TResult Function(_ChangeGradientState value)? changeGradientState,
    TResult Function(_AddOrRemoveGradientColor value)? addOrRemoveGradientColor,
    TResult Function(_UpdateGradientValueColor value)? updateGradientValueColor,
    TResult Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) {
    if (updateBoxSize != null) {
      return updateBoxSize(this);
    }
    return orElse();
  }
}

abstract class _UpdateBoxSize implements AnimatedBoxEvent {
  const factory _UpdateBoxSize({final double? height, final double? width}) =
      _$_UpdateBoxSize;

  double? get height;
  double? get width;
  @JsonKey(ignore: true)
  _$$_UpdateBoxSizeCopyWith<_$_UpdateBoxSize> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_ChangeGradientStateCopyWith<$Res> {
  factory _$$_ChangeGradientStateCopyWith(_$_ChangeGradientState value,
          $Res Function(_$_ChangeGradientState) then) =
      __$$_ChangeGradientStateCopyWithImpl<$Res>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$_ChangeGradientStateCopyWithImpl<$Res>
    extends _$AnimatedBoxEventCopyWithImpl<$Res, _$_ChangeGradientState>
    implements _$$_ChangeGradientStateCopyWith<$Res> {
  __$$_ChangeGradientStateCopyWithImpl(_$_ChangeGradientState _value,
      $Res Function(_$_ChangeGradientState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_ChangeGradientState(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_ChangeGradientState implements _ChangeGradientState {
  const _$_ChangeGradientState({required this.value});

  @override
  final int value;

  @override
  String toString() {
    return 'AnimatedBoxEvent.changeGradientState(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ChangeGradientState &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ChangeGradientStateCopyWith<_$_ChangeGradientState> get copyWith =>
      __$$_ChangeGradientStateCopyWithImpl<_$_ChangeGradientState>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() undoChanges,
    required TResult Function(double? x, double? y) updateOffset,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(Color? animatedBoxColor, Color? shadowColor)
        updateColor,
    required TResult Function(double? topLeft, double? topRight,
            double? bottomLeft, double? bottomRight)
        updateRadius,
    required TResult Function(double? height, double? width) updateBoxSize,
    required TResult Function(int value) changeGradientState,
    required TResult Function(bool? add, bool? remove) addOrRemoveGradientColor,
    required TResult Function(int id, Color? color, double? value)
        updateGradientValueColor,
    required TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)
        updateLinearGradientValue,
    required TResult Function(GradientDirectionModel centerRadiusGradient)
        updateGradientCenterValue,
  }) {
    return changeGradientState(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? undoChanges,
    TResult? Function(double? x, double? y)? updateOffset,
    TResult? Function(double value)? updateBlur,
    TResult? Function(double value)? updateSpread,
    TResult? Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult? Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult? Function(double? height, double? width)? updateBoxSize,
    TResult? Function(int value)? changeGradientState,
    TResult? Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult? Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult? Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult? Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
  }) {
    return changeGradientState?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? undoChanges,
    TResult Function(double? x, double? y)? updateOffset,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult Function(double? height, double? width)? updateBoxSize,
    TResult Function(int value)? changeGradientState,
    TResult Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) {
    if (changeGradientState != null) {
      return changeGradientState(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UndoChanges value) undoChanges,
    required TResult Function(_UpdateOffset value) updateOffset,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateSpread value) updateSpread,
    required TResult Function(_UpdateColor value) updateColor,
    required TResult Function(_UpdateRadius value) updateRadius,
    required TResult Function(_UpdateBoxSize value) updateBoxSize,
    required TResult Function(_ChangeGradientState value) changeGradientState,
    required TResult Function(_AddOrRemoveGradientColor value)
        addOrRemoveGradientColor,
    required TResult Function(_UpdateGradientValueColor value)
        updateGradientValueColor,
    required TResult Function(_UpdateLinearGradientValue value)
        updateLinearGradientValue,
    required TResult Function(_UpdateGradientCenterValue value)
        updateGradientCenterValue,
  }) {
    return changeGradientState(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialEvent value)? initial,
    TResult? Function(_UndoChanges value)? undoChanges,
    TResult? Function(_UpdateOffset value)? updateOffset,
    TResult? Function(_UpdateBlur value)? updateBlur,
    TResult? Function(_UpdateSpread value)? updateSpread,
    TResult? Function(_UpdateColor value)? updateColor,
    TResult? Function(_UpdateRadius value)? updateRadius,
    TResult? Function(_UpdateBoxSize value)? updateBoxSize,
    TResult? Function(_ChangeGradientState value)? changeGradientState,
    TResult? Function(_AddOrRemoveGradientColor value)?
        addOrRemoveGradientColor,
    TResult? Function(_UpdateGradientValueColor value)?
        updateGradientValueColor,
    TResult? Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult? Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
  }) {
    return changeGradientState?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UndoChanges value)? undoChanges,
    TResult Function(_UpdateOffset value)? updateOffset,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateSpread value)? updateSpread,
    TResult Function(_UpdateColor value)? updateColor,
    TResult Function(_UpdateRadius value)? updateRadius,
    TResult Function(_UpdateBoxSize value)? updateBoxSize,
    TResult Function(_ChangeGradientState value)? changeGradientState,
    TResult Function(_AddOrRemoveGradientColor value)? addOrRemoveGradientColor,
    TResult Function(_UpdateGradientValueColor value)? updateGradientValueColor,
    TResult Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) {
    if (changeGradientState != null) {
      return changeGradientState(this);
    }
    return orElse();
  }
}

abstract class _ChangeGradientState implements AnimatedBoxEvent {
  const factory _ChangeGradientState({required final int value}) =
      _$_ChangeGradientState;

  int get value;
  @JsonKey(ignore: true)
  _$$_ChangeGradientStateCopyWith<_$_ChangeGradientState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_AddOrRemoveGradientColorCopyWith<$Res> {
  factory _$$_AddOrRemoveGradientColorCopyWith(
          _$_AddOrRemoveGradientColor value,
          $Res Function(_$_AddOrRemoveGradientColor) then) =
      __$$_AddOrRemoveGradientColorCopyWithImpl<$Res>;
  @useResult
  $Res call({bool? add, bool? remove});
}

/// @nodoc
class __$$_AddOrRemoveGradientColorCopyWithImpl<$Res>
    extends _$AnimatedBoxEventCopyWithImpl<$Res, _$_AddOrRemoveGradientColor>
    implements _$$_AddOrRemoveGradientColorCopyWith<$Res> {
  __$$_AddOrRemoveGradientColorCopyWithImpl(_$_AddOrRemoveGradientColor _value,
      $Res Function(_$_AddOrRemoveGradientColor) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? add = freezed,
    Object? remove = freezed,
  }) {
    return _then(_$_AddOrRemoveGradientColor(
      add: freezed == add
          ? _value.add
          : add // ignore: cast_nullable_to_non_nullable
              as bool?,
      remove: freezed == remove
          ? _value.remove
          : remove // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc

class _$_AddOrRemoveGradientColor implements _AddOrRemoveGradientColor {
  const _$_AddOrRemoveGradientColor({this.add, this.remove});

  @override
  final bool? add;
  @override
  final bool? remove;

  @override
  String toString() {
    return 'AnimatedBoxEvent.addOrRemoveGradientColor(add: $add, remove: $remove)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AddOrRemoveGradientColor &&
            (identical(other.add, add) || other.add == add) &&
            (identical(other.remove, remove) || other.remove == remove));
  }

  @override
  int get hashCode => Object.hash(runtimeType, add, remove);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AddOrRemoveGradientColorCopyWith<_$_AddOrRemoveGradientColor>
      get copyWith => __$$_AddOrRemoveGradientColorCopyWithImpl<
          _$_AddOrRemoveGradientColor>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() undoChanges,
    required TResult Function(double? x, double? y) updateOffset,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(Color? animatedBoxColor, Color? shadowColor)
        updateColor,
    required TResult Function(double? topLeft, double? topRight,
            double? bottomLeft, double? bottomRight)
        updateRadius,
    required TResult Function(double? height, double? width) updateBoxSize,
    required TResult Function(int value) changeGradientState,
    required TResult Function(bool? add, bool? remove) addOrRemoveGradientColor,
    required TResult Function(int id, Color? color, double? value)
        updateGradientValueColor,
    required TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)
        updateLinearGradientValue,
    required TResult Function(GradientDirectionModel centerRadiusGradient)
        updateGradientCenterValue,
  }) {
    return addOrRemoveGradientColor(add, remove);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? undoChanges,
    TResult? Function(double? x, double? y)? updateOffset,
    TResult? Function(double value)? updateBlur,
    TResult? Function(double value)? updateSpread,
    TResult? Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult? Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult? Function(double? height, double? width)? updateBoxSize,
    TResult? Function(int value)? changeGradientState,
    TResult? Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult? Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult? Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult? Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
  }) {
    return addOrRemoveGradientColor?.call(add, remove);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? undoChanges,
    TResult Function(double? x, double? y)? updateOffset,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult Function(double? height, double? width)? updateBoxSize,
    TResult Function(int value)? changeGradientState,
    TResult Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) {
    if (addOrRemoveGradientColor != null) {
      return addOrRemoveGradientColor(add, remove);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UndoChanges value) undoChanges,
    required TResult Function(_UpdateOffset value) updateOffset,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateSpread value) updateSpread,
    required TResult Function(_UpdateColor value) updateColor,
    required TResult Function(_UpdateRadius value) updateRadius,
    required TResult Function(_UpdateBoxSize value) updateBoxSize,
    required TResult Function(_ChangeGradientState value) changeGradientState,
    required TResult Function(_AddOrRemoveGradientColor value)
        addOrRemoveGradientColor,
    required TResult Function(_UpdateGradientValueColor value)
        updateGradientValueColor,
    required TResult Function(_UpdateLinearGradientValue value)
        updateLinearGradientValue,
    required TResult Function(_UpdateGradientCenterValue value)
        updateGradientCenterValue,
  }) {
    return addOrRemoveGradientColor(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialEvent value)? initial,
    TResult? Function(_UndoChanges value)? undoChanges,
    TResult? Function(_UpdateOffset value)? updateOffset,
    TResult? Function(_UpdateBlur value)? updateBlur,
    TResult? Function(_UpdateSpread value)? updateSpread,
    TResult? Function(_UpdateColor value)? updateColor,
    TResult? Function(_UpdateRadius value)? updateRadius,
    TResult? Function(_UpdateBoxSize value)? updateBoxSize,
    TResult? Function(_ChangeGradientState value)? changeGradientState,
    TResult? Function(_AddOrRemoveGradientColor value)?
        addOrRemoveGradientColor,
    TResult? Function(_UpdateGradientValueColor value)?
        updateGradientValueColor,
    TResult? Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult? Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
  }) {
    return addOrRemoveGradientColor?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UndoChanges value)? undoChanges,
    TResult Function(_UpdateOffset value)? updateOffset,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateSpread value)? updateSpread,
    TResult Function(_UpdateColor value)? updateColor,
    TResult Function(_UpdateRadius value)? updateRadius,
    TResult Function(_UpdateBoxSize value)? updateBoxSize,
    TResult Function(_ChangeGradientState value)? changeGradientState,
    TResult Function(_AddOrRemoveGradientColor value)? addOrRemoveGradientColor,
    TResult Function(_UpdateGradientValueColor value)? updateGradientValueColor,
    TResult Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) {
    if (addOrRemoveGradientColor != null) {
      return addOrRemoveGradientColor(this);
    }
    return orElse();
  }
}

abstract class _AddOrRemoveGradientColor implements AnimatedBoxEvent {
  const factory _AddOrRemoveGradientColor(
      {final bool? add, final bool? remove}) = _$_AddOrRemoveGradientColor;

  bool? get add;
  bool? get remove;
  @JsonKey(ignore: true)
  _$$_AddOrRemoveGradientColorCopyWith<_$_AddOrRemoveGradientColor>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UpdateGradientValueColorCopyWith<$Res> {
  factory _$$_UpdateGradientValueColorCopyWith(
          _$_UpdateGradientValueColor value,
          $Res Function(_$_UpdateGradientValueColor) then) =
      __$$_UpdateGradientValueColorCopyWithImpl<$Res>;
  @useResult
  $Res call({int id, Color? color, double? value});
}

/// @nodoc
class __$$_UpdateGradientValueColorCopyWithImpl<$Res>
    extends _$AnimatedBoxEventCopyWithImpl<$Res, _$_UpdateGradientValueColor>
    implements _$$_UpdateGradientValueColorCopyWith<$Res> {
  __$$_UpdateGradientValueColorCopyWithImpl(_$_UpdateGradientValueColor _value,
      $Res Function(_$_UpdateGradientValueColor) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? color = freezed,
    Object? value = freezed,
  }) {
    return _then(_$_UpdateGradientValueColor(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as double?,
    ));
  }
}

/// @nodoc

class _$_UpdateGradientValueColor implements _UpdateGradientValueColor {
  const _$_UpdateGradientValueColor({required this.id, this.color, this.value});

  @override
  final int id;
  @override
  final Color? color;
  @override
  final double? value;

  @override
  String toString() {
    return 'AnimatedBoxEvent.updateGradientValueColor(id: $id, color: $color, value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateGradientValueColor &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.color, color) || other.color == color) &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id, color, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpdateGradientValueColorCopyWith<_$_UpdateGradientValueColor>
      get copyWith => __$$_UpdateGradientValueColorCopyWithImpl<
          _$_UpdateGradientValueColor>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() undoChanges,
    required TResult Function(double? x, double? y) updateOffset,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(Color? animatedBoxColor, Color? shadowColor)
        updateColor,
    required TResult Function(double? topLeft, double? topRight,
            double? bottomLeft, double? bottomRight)
        updateRadius,
    required TResult Function(double? height, double? width) updateBoxSize,
    required TResult Function(int value) changeGradientState,
    required TResult Function(bool? add, bool? remove) addOrRemoveGradientColor,
    required TResult Function(int id, Color? color, double? value)
        updateGradientValueColor,
    required TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)
        updateLinearGradientValue,
    required TResult Function(GradientDirectionModel centerRadiusGradient)
        updateGradientCenterValue,
  }) {
    return updateGradientValueColor(id, color, value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? undoChanges,
    TResult? Function(double? x, double? y)? updateOffset,
    TResult? Function(double value)? updateBlur,
    TResult? Function(double value)? updateSpread,
    TResult? Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult? Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult? Function(double? height, double? width)? updateBoxSize,
    TResult? Function(int value)? changeGradientState,
    TResult? Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult? Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult? Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult? Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
  }) {
    return updateGradientValueColor?.call(id, color, value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? undoChanges,
    TResult Function(double? x, double? y)? updateOffset,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult Function(double? height, double? width)? updateBoxSize,
    TResult Function(int value)? changeGradientState,
    TResult Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) {
    if (updateGradientValueColor != null) {
      return updateGradientValueColor(id, color, value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UndoChanges value) undoChanges,
    required TResult Function(_UpdateOffset value) updateOffset,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateSpread value) updateSpread,
    required TResult Function(_UpdateColor value) updateColor,
    required TResult Function(_UpdateRadius value) updateRadius,
    required TResult Function(_UpdateBoxSize value) updateBoxSize,
    required TResult Function(_ChangeGradientState value) changeGradientState,
    required TResult Function(_AddOrRemoveGradientColor value)
        addOrRemoveGradientColor,
    required TResult Function(_UpdateGradientValueColor value)
        updateGradientValueColor,
    required TResult Function(_UpdateLinearGradientValue value)
        updateLinearGradientValue,
    required TResult Function(_UpdateGradientCenterValue value)
        updateGradientCenterValue,
  }) {
    return updateGradientValueColor(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialEvent value)? initial,
    TResult? Function(_UndoChanges value)? undoChanges,
    TResult? Function(_UpdateOffset value)? updateOffset,
    TResult? Function(_UpdateBlur value)? updateBlur,
    TResult? Function(_UpdateSpread value)? updateSpread,
    TResult? Function(_UpdateColor value)? updateColor,
    TResult? Function(_UpdateRadius value)? updateRadius,
    TResult? Function(_UpdateBoxSize value)? updateBoxSize,
    TResult? Function(_ChangeGradientState value)? changeGradientState,
    TResult? Function(_AddOrRemoveGradientColor value)?
        addOrRemoveGradientColor,
    TResult? Function(_UpdateGradientValueColor value)?
        updateGradientValueColor,
    TResult? Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult? Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
  }) {
    return updateGradientValueColor?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UndoChanges value)? undoChanges,
    TResult Function(_UpdateOffset value)? updateOffset,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateSpread value)? updateSpread,
    TResult Function(_UpdateColor value)? updateColor,
    TResult Function(_UpdateRadius value)? updateRadius,
    TResult Function(_UpdateBoxSize value)? updateBoxSize,
    TResult Function(_ChangeGradientState value)? changeGradientState,
    TResult Function(_AddOrRemoveGradientColor value)? addOrRemoveGradientColor,
    TResult Function(_UpdateGradientValueColor value)? updateGradientValueColor,
    TResult Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) {
    if (updateGradientValueColor != null) {
      return updateGradientValueColor(this);
    }
    return orElse();
  }
}

abstract class _UpdateGradientValueColor implements AnimatedBoxEvent {
  const factory _UpdateGradientValueColor(
      {required final int id,
      final Color? color,
      final double? value}) = _$_UpdateGradientValueColor;

  int get id;
  Color? get color;
  double? get value;
  @JsonKey(ignore: true)
  _$$_UpdateGradientValueColorCopyWith<_$_UpdateGradientValueColor>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UpdateLinearGradientValueCopyWith<$Res> {
  factory _$$_UpdateLinearGradientValueCopyWith(
          _$_UpdateLinearGradientValue value,
          $Res Function(_$_UpdateLinearGradientValue) then) =
      __$$_UpdateLinearGradientValueCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {GradientDirectionModel? beginLinearGradient,
      GradientDirectionModel? endLinearGradient});

  $GradientDirectionModelCopyWith<$Res>? get beginLinearGradient;
  $GradientDirectionModelCopyWith<$Res>? get endLinearGradient;
}

/// @nodoc
class __$$_UpdateLinearGradientValueCopyWithImpl<$Res>
    extends _$AnimatedBoxEventCopyWithImpl<$Res, _$_UpdateLinearGradientValue>
    implements _$$_UpdateLinearGradientValueCopyWith<$Res> {
  __$$_UpdateLinearGradientValueCopyWithImpl(
      _$_UpdateLinearGradientValue _value,
      $Res Function(_$_UpdateLinearGradientValue) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? beginLinearGradient = freezed,
    Object? endLinearGradient = freezed,
  }) {
    return _then(_$_UpdateLinearGradientValue(
      beginLinearGradient: freezed == beginLinearGradient
          ? _value.beginLinearGradient
          : beginLinearGradient // ignore: cast_nullable_to_non_nullable
              as GradientDirectionModel?,
      endLinearGradient: freezed == endLinearGradient
          ? _value.endLinearGradient
          : endLinearGradient // ignore: cast_nullable_to_non_nullable
              as GradientDirectionModel?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $GradientDirectionModelCopyWith<$Res>? get beginLinearGradient {
    if (_value.beginLinearGradient == null) {
      return null;
    }

    return $GradientDirectionModelCopyWith<$Res>(_value.beginLinearGradient!,
        (value) {
      return _then(_value.copyWith(beginLinearGradient: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $GradientDirectionModelCopyWith<$Res>? get endLinearGradient {
    if (_value.endLinearGradient == null) {
      return null;
    }

    return $GradientDirectionModelCopyWith<$Res>(_value.endLinearGradient!,
        (value) {
      return _then(_value.copyWith(endLinearGradient: value));
    });
  }
}

/// @nodoc

class _$_UpdateLinearGradientValue implements _UpdateLinearGradientValue {
  const _$_UpdateLinearGradientValue(
      {this.beginLinearGradient, this.endLinearGradient});

  @override
  final GradientDirectionModel? beginLinearGradient;
  @override
  final GradientDirectionModel? endLinearGradient;

  @override
  String toString() {
    return 'AnimatedBoxEvent.updateLinearGradientValue(beginLinearGradient: $beginLinearGradient, endLinearGradient: $endLinearGradient)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateLinearGradientValue &&
            (identical(other.beginLinearGradient, beginLinearGradient) ||
                other.beginLinearGradient == beginLinearGradient) &&
            (identical(other.endLinearGradient, endLinearGradient) ||
                other.endLinearGradient == endLinearGradient));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, beginLinearGradient, endLinearGradient);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpdateLinearGradientValueCopyWith<_$_UpdateLinearGradientValue>
      get copyWith => __$$_UpdateLinearGradientValueCopyWithImpl<
          _$_UpdateLinearGradientValue>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() undoChanges,
    required TResult Function(double? x, double? y) updateOffset,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(Color? animatedBoxColor, Color? shadowColor)
        updateColor,
    required TResult Function(double? topLeft, double? topRight,
            double? bottomLeft, double? bottomRight)
        updateRadius,
    required TResult Function(double? height, double? width) updateBoxSize,
    required TResult Function(int value) changeGradientState,
    required TResult Function(bool? add, bool? remove) addOrRemoveGradientColor,
    required TResult Function(int id, Color? color, double? value)
        updateGradientValueColor,
    required TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)
        updateLinearGradientValue,
    required TResult Function(GradientDirectionModel centerRadiusGradient)
        updateGradientCenterValue,
  }) {
    return updateLinearGradientValue(beginLinearGradient, endLinearGradient);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? undoChanges,
    TResult? Function(double? x, double? y)? updateOffset,
    TResult? Function(double value)? updateBlur,
    TResult? Function(double value)? updateSpread,
    TResult? Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult? Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult? Function(double? height, double? width)? updateBoxSize,
    TResult? Function(int value)? changeGradientState,
    TResult? Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult? Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult? Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult? Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
  }) {
    return updateLinearGradientValue?.call(
        beginLinearGradient, endLinearGradient);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? undoChanges,
    TResult Function(double? x, double? y)? updateOffset,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult Function(double? height, double? width)? updateBoxSize,
    TResult Function(int value)? changeGradientState,
    TResult Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) {
    if (updateLinearGradientValue != null) {
      return updateLinearGradientValue(beginLinearGradient, endLinearGradient);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UndoChanges value) undoChanges,
    required TResult Function(_UpdateOffset value) updateOffset,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateSpread value) updateSpread,
    required TResult Function(_UpdateColor value) updateColor,
    required TResult Function(_UpdateRadius value) updateRadius,
    required TResult Function(_UpdateBoxSize value) updateBoxSize,
    required TResult Function(_ChangeGradientState value) changeGradientState,
    required TResult Function(_AddOrRemoveGradientColor value)
        addOrRemoveGradientColor,
    required TResult Function(_UpdateGradientValueColor value)
        updateGradientValueColor,
    required TResult Function(_UpdateLinearGradientValue value)
        updateLinearGradientValue,
    required TResult Function(_UpdateGradientCenterValue value)
        updateGradientCenterValue,
  }) {
    return updateLinearGradientValue(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialEvent value)? initial,
    TResult? Function(_UndoChanges value)? undoChanges,
    TResult? Function(_UpdateOffset value)? updateOffset,
    TResult? Function(_UpdateBlur value)? updateBlur,
    TResult? Function(_UpdateSpread value)? updateSpread,
    TResult? Function(_UpdateColor value)? updateColor,
    TResult? Function(_UpdateRadius value)? updateRadius,
    TResult? Function(_UpdateBoxSize value)? updateBoxSize,
    TResult? Function(_ChangeGradientState value)? changeGradientState,
    TResult? Function(_AddOrRemoveGradientColor value)?
        addOrRemoveGradientColor,
    TResult? Function(_UpdateGradientValueColor value)?
        updateGradientValueColor,
    TResult? Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult? Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
  }) {
    return updateLinearGradientValue?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UndoChanges value)? undoChanges,
    TResult Function(_UpdateOffset value)? updateOffset,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateSpread value)? updateSpread,
    TResult Function(_UpdateColor value)? updateColor,
    TResult Function(_UpdateRadius value)? updateRadius,
    TResult Function(_UpdateBoxSize value)? updateBoxSize,
    TResult Function(_ChangeGradientState value)? changeGradientState,
    TResult Function(_AddOrRemoveGradientColor value)? addOrRemoveGradientColor,
    TResult Function(_UpdateGradientValueColor value)? updateGradientValueColor,
    TResult Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) {
    if (updateLinearGradientValue != null) {
      return updateLinearGradientValue(this);
    }
    return orElse();
  }
}

abstract class _UpdateLinearGradientValue implements AnimatedBoxEvent {
  const factory _UpdateLinearGradientValue(
          {final GradientDirectionModel? beginLinearGradient,
          final GradientDirectionModel? endLinearGradient}) =
      _$_UpdateLinearGradientValue;

  GradientDirectionModel? get beginLinearGradient;
  GradientDirectionModel? get endLinearGradient;
  @JsonKey(ignore: true)
  _$$_UpdateLinearGradientValueCopyWith<_$_UpdateLinearGradientValue>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UpdateGradientCenterValueCopyWith<$Res> {
  factory _$$_UpdateGradientCenterValueCopyWith(
          _$_UpdateGradientCenterValue value,
          $Res Function(_$_UpdateGradientCenterValue) then) =
      __$$_UpdateGradientCenterValueCopyWithImpl<$Res>;
  @useResult
  $Res call({GradientDirectionModel centerRadiusGradient});

  $GradientDirectionModelCopyWith<$Res> get centerRadiusGradient;
}

/// @nodoc
class __$$_UpdateGradientCenterValueCopyWithImpl<$Res>
    extends _$AnimatedBoxEventCopyWithImpl<$Res, _$_UpdateGradientCenterValue>
    implements _$$_UpdateGradientCenterValueCopyWith<$Res> {
  __$$_UpdateGradientCenterValueCopyWithImpl(
      _$_UpdateGradientCenterValue _value,
      $Res Function(_$_UpdateGradientCenterValue) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? centerRadiusGradient = null,
  }) {
    return _then(_$_UpdateGradientCenterValue(
      centerRadiusGradient: null == centerRadiusGradient
          ? _value.centerRadiusGradient
          : centerRadiusGradient // ignore: cast_nullable_to_non_nullable
              as GradientDirectionModel,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $GradientDirectionModelCopyWith<$Res> get centerRadiusGradient {
    return $GradientDirectionModelCopyWith<$Res>(_value.centerRadiusGradient,
        (value) {
      return _then(_value.copyWith(centerRadiusGradient: value));
    });
  }
}

/// @nodoc

class _$_UpdateGradientCenterValue implements _UpdateGradientCenterValue {
  const _$_UpdateGradientCenterValue({required this.centerRadiusGradient});

  @override
  final GradientDirectionModel centerRadiusGradient;

  @override
  String toString() {
    return 'AnimatedBoxEvent.updateGradientCenterValue(centerRadiusGradient: $centerRadiusGradient)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateGradientCenterValue &&
            (identical(other.centerRadiusGradient, centerRadiusGradient) ||
                other.centerRadiusGradient == centerRadiusGradient));
  }

  @override
  int get hashCode => Object.hash(runtimeType, centerRadiusGradient);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpdateGradientCenterValueCopyWith<_$_UpdateGradientCenterValue>
      get copyWith => __$$_UpdateGradientCenterValueCopyWithImpl<
          _$_UpdateGradientCenterValue>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() undoChanges,
    required TResult Function(double? x, double? y) updateOffset,
    required TResult Function(double value) updateBlur,
    required TResult Function(double value) updateSpread,
    required TResult Function(Color? animatedBoxColor, Color? shadowColor)
        updateColor,
    required TResult Function(double? topLeft, double? topRight,
            double? bottomLeft, double? bottomRight)
        updateRadius,
    required TResult Function(double? height, double? width) updateBoxSize,
    required TResult Function(int value) changeGradientState,
    required TResult Function(bool? add, bool? remove) addOrRemoveGradientColor,
    required TResult Function(int id, Color? color, double? value)
        updateGradientValueColor,
    required TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)
        updateLinearGradientValue,
    required TResult Function(GradientDirectionModel centerRadiusGradient)
        updateGradientCenterValue,
  }) {
    return updateGradientCenterValue(centerRadiusGradient);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? undoChanges,
    TResult? Function(double? x, double? y)? updateOffset,
    TResult? Function(double value)? updateBlur,
    TResult? Function(double value)? updateSpread,
    TResult? Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult? Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult? Function(double? height, double? width)? updateBoxSize,
    TResult? Function(int value)? changeGradientState,
    TResult? Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult? Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult? Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult? Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
  }) {
    return updateGradientCenterValue?.call(centerRadiusGradient);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? undoChanges,
    TResult Function(double? x, double? y)? updateOffset,
    TResult Function(double value)? updateBlur,
    TResult Function(double value)? updateSpread,
    TResult Function(Color? animatedBoxColor, Color? shadowColor)? updateColor,
    TResult Function(double? topLeft, double? topRight, double? bottomLeft,
            double? bottomRight)?
        updateRadius,
    TResult Function(double? height, double? width)? updateBoxSize,
    TResult Function(int value)? changeGradientState,
    TResult Function(bool? add, bool? remove)? addOrRemoveGradientColor,
    TResult Function(int id, Color? color, double? value)?
        updateGradientValueColor,
    TResult Function(GradientDirectionModel? beginLinearGradient,
            GradientDirectionModel? endLinearGradient)?
        updateLinearGradientValue,
    TResult Function(GradientDirectionModel centerRadiusGradient)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) {
    if (updateGradientCenterValue != null) {
      return updateGradientCenterValue(centerRadiusGradient);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialEvent value) initial,
    required TResult Function(_UndoChanges value) undoChanges,
    required TResult Function(_UpdateOffset value) updateOffset,
    required TResult Function(_UpdateBlur value) updateBlur,
    required TResult Function(_UpdateSpread value) updateSpread,
    required TResult Function(_UpdateColor value) updateColor,
    required TResult Function(_UpdateRadius value) updateRadius,
    required TResult Function(_UpdateBoxSize value) updateBoxSize,
    required TResult Function(_ChangeGradientState value) changeGradientState,
    required TResult Function(_AddOrRemoveGradientColor value)
        addOrRemoveGradientColor,
    required TResult Function(_UpdateGradientValueColor value)
        updateGradientValueColor,
    required TResult Function(_UpdateLinearGradientValue value)
        updateLinearGradientValue,
    required TResult Function(_UpdateGradientCenterValue value)
        updateGradientCenterValue,
  }) {
    return updateGradientCenterValue(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialEvent value)? initial,
    TResult? Function(_UndoChanges value)? undoChanges,
    TResult? Function(_UpdateOffset value)? updateOffset,
    TResult? Function(_UpdateBlur value)? updateBlur,
    TResult? Function(_UpdateSpread value)? updateSpread,
    TResult? Function(_UpdateColor value)? updateColor,
    TResult? Function(_UpdateRadius value)? updateRadius,
    TResult? Function(_UpdateBoxSize value)? updateBoxSize,
    TResult? Function(_ChangeGradientState value)? changeGradientState,
    TResult? Function(_AddOrRemoveGradientColor value)?
        addOrRemoveGradientColor,
    TResult? Function(_UpdateGradientValueColor value)?
        updateGradientValueColor,
    TResult? Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult? Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
  }) {
    return updateGradientCenterValue?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialEvent value)? initial,
    TResult Function(_UndoChanges value)? undoChanges,
    TResult Function(_UpdateOffset value)? updateOffset,
    TResult Function(_UpdateBlur value)? updateBlur,
    TResult Function(_UpdateSpread value)? updateSpread,
    TResult Function(_UpdateColor value)? updateColor,
    TResult Function(_UpdateRadius value)? updateRadius,
    TResult Function(_UpdateBoxSize value)? updateBoxSize,
    TResult Function(_ChangeGradientState value)? changeGradientState,
    TResult Function(_AddOrRemoveGradientColor value)? addOrRemoveGradientColor,
    TResult Function(_UpdateGradientValueColor value)? updateGradientValueColor,
    TResult Function(_UpdateLinearGradientValue value)?
        updateLinearGradientValue,
    TResult Function(_UpdateGradientCenterValue value)?
        updateGradientCenterValue,
    required TResult orElse(),
  }) {
    if (updateGradientCenterValue != null) {
      return updateGradientCenterValue(this);
    }
    return orElse();
  }
}

abstract class _UpdateGradientCenterValue implements AnimatedBoxEvent {
  const factory _UpdateGradientCenterValue(
          {required final GradientDirectionModel centerRadiusGradient}) =
      _$_UpdateGradientCenterValue;

  GradientDirectionModel get centerRadiusGradient;
  @JsonKey(ignore: true)
  _$$_UpdateGradientCenterValueCopyWith<_$_UpdateGradientCenterValue>
      get copyWith => throw _privateConstructorUsedError;
}

AnimatedBoxState _$AnimatedBoxStateFromJson(Map<String, dynamic> json) {
  return _AnimatedBoxState.fromJson(json);
}

/// @nodoc
mixin _$AnimatedBoxState {
  double get offsetDx => throw _privateConstructorUsedError;
  double get offsetDy => throw _privateConstructorUsedError;
  double get boxWidth => throw _privateConstructorUsedError;
  double get boxHeight => throw _privateConstructorUsedError;
  int get shadowColor => throw _privateConstructorUsedError;
  int get animatedBoxColor => throw _privateConstructorUsedError;
  double get blurRadius => throw _privateConstructorUsedError;
  double get spreadRadius => throw _privateConstructorUsedError;
  BorderRadiusModel get borderRadius => throw _privateConstructorUsedError;
  List<GradientColorModel> get gradientColors =>
      throw _privateConstructorUsedError;
  GradientStateModel get gradientState => throw _privateConstructorUsedError;
  GradientDirectionModel get beginLinearGradient =>
      throw _privateConstructorUsedError;
  GradientDirectionModel get endLinearGradient =>
      throw _privateConstructorUsedError;
  GradientDirectionModel get centerRadiusGradient =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AnimatedBoxStateCopyWith<AnimatedBoxState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnimatedBoxStateCopyWith<$Res> {
  factory $AnimatedBoxStateCopyWith(
          AnimatedBoxState value, $Res Function(AnimatedBoxState) then) =
      _$AnimatedBoxStateCopyWithImpl<$Res, AnimatedBoxState>;
  @useResult
  $Res call(
      {double offsetDx,
      double offsetDy,
      double boxWidth,
      double boxHeight,
      int shadowColor,
      int animatedBoxColor,
      double blurRadius,
      double spreadRadius,
      BorderRadiusModel borderRadius,
      List<GradientColorModel> gradientColors,
      GradientStateModel gradientState,
      GradientDirectionModel beginLinearGradient,
      GradientDirectionModel endLinearGradient,
      GradientDirectionModel centerRadiusGradient});

  $BorderRadiusModelCopyWith<$Res> get borderRadius;
  $GradientDirectionModelCopyWith<$Res> get beginLinearGradient;
  $GradientDirectionModelCopyWith<$Res> get endLinearGradient;
  $GradientDirectionModelCopyWith<$Res> get centerRadiusGradient;
}

/// @nodoc
class _$AnimatedBoxStateCopyWithImpl<$Res, $Val extends AnimatedBoxState>
    implements $AnimatedBoxStateCopyWith<$Res> {
  _$AnimatedBoxStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offsetDx = null,
    Object? offsetDy = null,
    Object? boxWidth = null,
    Object? boxHeight = null,
    Object? shadowColor = null,
    Object? animatedBoxColor = null,
    Object? blurRadius = null,
    Object? spreadRadius = null,
    Object? borderRadius = null,
    Object? gradientColors = null,
    Object? gradientState = freezed,
    Object? beginLinearGradient = null,
    Object? endLinearGradient = null,
    Object? centerRadiusGradient = null,
  }) {
    return _then(_value.copyWith(
      offsetDx: null == offsetDx
          ? _value.offsetDx
          : offsetDx // ignore: cast_nullable_to_non_nullable
              as double,
      offsetDy: null == offsetDy
          ? _value.offsetDy
          : offsetDy // ignore: cast_nullable_to_non_nullable
              as double,
      boxWidth: null == boxWidth
          ? _value.boxWidth
          : boxWidth // ignore: cast_nullable_to_non_nullable
              as double,
      boxHeight: null == boxHeight
          ? _value.boxHeight
          : boxHeight // ignore: cast_nullable_to_non_nullable
              as double,
      shadowColor: null == shadowColor
          ? _value.shadowColor
          : shadowColor // ignore: cast_nullable_to_non_nullable
              as int,
      animatedBoxColor: null == animatedBoxColor
          ? _value.animatedBoxColor
          : animatedBoxColor // ignore: cast_nullable_to_non_nullable
              as int,
      blurRadius: null == blurRadius
          ? _value.blurRadius
          : blurRadius // ignore: cast_nullable_to_non_nullable
              as double,
      spreadRadius: null == spreadRadius
          ? _value.spreadRadius
          : spreadRadius // ignore: cast_nullable_to_non_nullable
              as double,
      borderRadius: null == borderRadius
          ? _value.borderRadius
          : borderRadius // ignore: cast_nullable_to_non_nullable
              as BorderRadiusModel,
      gradientColors: null == gradientColors
          ? _value.gradientColors
          : gradientColors // ignore: cast_nullable_to_non_nullable
              as List<GradientColorModel>,
      gradientState: freezed == gradientState
          ? _value.gradientState
          : gradientState // ignore: cast_nullable_to_non_nullable
              as GradientStateModel,
      beginLinearGradient: null == beginLinearGradient
          ? _value.beginLinearGradient
          : beginLinearGradient // ignore: cast_nullable_to_non_nullable
              as GradientDirectionModel,
      endLinearGradient: null == endLinearGradient
          ? _value.endLinearGradient
          : endLinearGradient // ignore: cast_nullable_to_non_nullable
              as GradientDirectionModel,
      centerRadiusGradient: null == centerRadiusGradient
          ? _value.centerRadiusGradient
          : centerRadiusGradient // ignore: cast_nullable_to_non_nullable
              as GradientDirectionModel,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $BorderRadiusModelCopyWith<$Res> get borderRadius {
    return $BorderRadiusModelCopyWith<$Res>(_value.borderRadius, (value) {
      return _then(_value.copyWith(borderRadius: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $GradientDirectionModelCopyWith<$Res> get beginLinearGradient {
    return $GradientDirectionModelCopyWith<$Res>(_value.beginLinearGradient,
        (value) {
      return _then(_value.copyWith(beginLinearGradient: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $GradientDirectionModelCopyWith<$Res> get endLinearGradient {
    return $GradientDirectionModelCopyWith<$Res>(_value.endLinearGradient,
        (value) {
      return _then(_value.copyWith(endLinearGradient: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $GradientDirectionModelCopyWith<$Res> get centerRadiusGradient {
    return $GradientDirectionModelCopyWith<$Res>(_value.centerRadiusGradient,
        (value) {
      return _then(_value.copyWith(centerRadiusGradient: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AnimatedBoxStateCopyWith<$Res>
    implements $AnimatedBoxStateCopyWith<$Res> {
  factory _$$_AnimatedBoxStateCopyWith(
          _$_AnimatedBoxState value, $Res Function(_$_AnimatedBoxState) then) =
      __$$_AnimatedBoxStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double offsetDx,
      double offsetDy,
      double boxWidth,
      double boxHeight,
      int shadowColor,
      int animatedBoxColor,
      double blurRadius,
      double spreadRadius,
      BorderRadiusModel borderRadius,
      List<GradientColorModel> gradientColors,
      GradientStateModel gradientState,
      GradientDirectionModel beginLinearGradient,
      GradientDirectionModel endLinearGradient,
      GradientDirectionModel centerRadiusGradient});

  @override
  $BorderRadiusModelCopyWith<$Res> get borderRadius;
  @override
  $GradientDirectionModelCopyWith<$Res> get beginLinearGradient;
  @override
  $GradientDirectionModelCopyWith<$Res> get endLinearGradient;
  @override
  $GradientDirectionModelCopyWith<$Res> get centerRadiusGradient;
}

/// @nodoc
class __$$_AnimatedBoxStateCopyWithImpl<$Res>
    extends _$AnimatedBoxStateCopyWithImpl<$Res, _$_AnimatedBoxState>
    implements _$$_AnimatedBoxStateCopyWith<$Res> {
  __$$_AnimatedBoxStateCopyWithImpl(
      _$_AnimatedBoxState _value, $Res Function(_$_AnimatedBoxState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offsetDx = null,
    Object? offsetDy = null,
    Object? boxWidth = null,
    Object? boxHeight = null,
    Object? shadowColor = null,
    Object? animatedBoxColor = null,
    Object? blurRadius = null,
    Object? spreadRadius = null,
    Object? borderRadius = null,
    Object? gradientColors = null,
    Object? gradientState = freezed,
    Object? beginLinearGradient = null,
    Object? endLinearGradient = null,
    Object? centerRadiusGradient = null,
  }) {
    return _then(_$_AnimatedBoxState(
      offsetDx: null == offsetDx
          ? _value.offsetDx
          : offsetDx // ignore: cast_nullable_to_non_nullable
              as double,
      offsetDy: null == offsetDy
          ? _value.offsetDy
          : offsetDy // ignore: cast_nullable_to_non_nullable
              as double,
      boxWidth: null == boxWidth
          ? _value.boxWidth
          : boxWidth // ignore: cast_nullable_to_non_nullable
              as double,
      boxHeight: null == boxHeight
          ? _value.boxHeight
          : boxHeight // ignore: cast_nullable_to_non_nullable
              as double,
      shadowColor: null == shadowColor
          ? _value.shadowColor
          : shadowColor // ignore: cast_nullable_to_non_nullable
              as int,
      animatedBoxColor: null == animatedBoxColor
          ? _value.animatedBoxColor
          : animatedBoxColor // ignore: cast_nullable_to_non_nullable
              as int,
      blurRadius: null == blurRadius
          ? _value.blurRadius
          : blurRadius // ignore: cast_nullable_to_non_nullable
              as double,
      spreadRadius: null == spreadRadius
          ? _value.spreadRadius
          : spreadRadius // ignore: cast_nullable_to_non_nullable
              as double,
      borderRadius: null == borderRadius
          ? _value.borderRadius
          : borderRadius // ignore: cast_nullable_to_non_nullable
              as BorderRadiusModel,
      gradientColors: null == gradientColors
          ? _value._gradientColors
          : gradientColors // ignore: cast_nullable_to_non_nullable
              as List<GradientColorModel>,
      gradientState: freezed == gradientState
          ? _value.gradientState
          : gradientState // ignore: cast_nullable_to_non_nullable
              as GradientStateModel,
      beginLinearGradient: null == beginLinearGradient
          ? _value.beginLinearGradient
          : beginLinearGradient // ignore: cast_nullable_to_non_nullable
              as GradientDirectionModel,
      endLinearGradient: null == endLinearGradient
          ? _value.endLinearGradient
          : endLinearGradient // ignore: cast_nullable_to_non_nullable
              as GradientDirectionModel,
      centerRadiusGradient: null == centerRadiusGradient
          ? _value.centerRadiusGradient
          : centerRadiusGradient // ignore: cast_nullable_to_non_nullable
              as GradientDirectionModel,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AnimatedBoxState implements _AnimatedBoxState {
  const _$_AnimatedBoxState(
      {this.offsetDx = 0.0,
      this.offsetDy = 0.0,
      this.boxWidth = 350.0,
      this.boxHeight = 350.0,
      this.shadowColor = 4279308052,
      this.animatedBoxColor = 4293848814,
      this.blurRadius = 0.0,
      this.spreadRadius = 0.0,
      this.borderRadius = const BorderRadiusModel(
          bottomLeftRadius: 0,
          bottomRightRadius: 0,
          topLeftRadius: 0,
          topRightRadius: 0),
      final List<GradientColorModel> gradientColors = const [
        GradientColorModel(id: 0, color: 4278267456, value: 0),
        GradientColorModel(id: 1, color: 4278422668, value: 1)
      ],
      this.gradientState = const GradientStateModel(
          isGradientEnabled: false,
          isLinearGradient: false,
          isRadialGradient: false),
      this.beginLinearGradient = const GradientDirectionModel(
          name: 'TopLeft', aligmentX: -1.0, aligmentY: -1.0),
      this.endLinearGradient = const GradientDirectionModel(
          name: 'BottomRight', aligmentX: 1.0, aligmentY: 1.0),
      this.centerRadiusGradient = const GradientDirectionModel(
          name: 'Center', aligmentX: 0.0, aligmentY: 0.0)})
      : _gradientColors = gradientColors;

  factory _$_AnimatedBoxState.fromJson(Map<String, dynamic> json) =>
      _$$_AnimatedBoxStateFromJson(json);

  @override
  @JsonKey()
  final double offsetDx;
  @override
  @JsonKey()
  final double offsetDy;
  @override
  @JsonKey()
  final double boxWidth;
  @override
  @JsonKey()
  final double boxHeight;
  @override
  @JsonKey()
  final int shadowColor;
  @override
  @JsonKey()
  final int animatedBoxColor;
  @override
  @JsonKey()
  final double blurRadius;
  @override
  @JsonKey()
  final double spreadRadius;
  @override
  @JsonKey()
  final BorderRadiusModel borderRadius;
  final List<GradientColorModel> _gradientColors;
  @override
  @JsonKey()
  List<GradientColorModel> get gradientColors {
    if (_gradientColors is EqualUnmodifiableListView) return _gradientColors;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_gradientColors);
  }

  @override
  @JsonKey()
  final GradientStateModel gradientState;
  @override
  @JsonKey()
  final GradientDirectionModel beginLinearGradient;
  @override
  @JsonKey()
  final GradientDirectionModel endLinearGradient;
  @override
  @JsonKey()
  final GradientDirectionModel centerRadiusGradient;

  @override
  String toString() {
    return 'AnimatedBoxState(offsetDx: $offsetDx, offsetDy: $offsetDy, boxWidth: $boxWidth, boxHeight: $boxHeight, shadowColor: $shadowColor, animatedBoxColor: $animatedBoxColor, blurRadius: $blurRadius, spreadRadius: $spreadRadius, borderRadius: $borderRadius, gradientColors: $gradientColors, gradientState: $gradientState, beginLinearGradient: $beginLinearGradient, endLinearGradient: $endLinearGradient, centerRadiusGradient: $centerRadiusGradient)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AnimatedBoxState &&
            (identical(other.offsetDx, offsetDx) ||
                other.offsetDx == offsetDx) &&
            (identical(other.offsetDy, offsetDy) ||
                other.offsetDy == offsetDy) &&
            (identical(other.boxWidth, boxWidth) ||
                other.boxWidth == boxWidth) &&
            (identical(other.boxHeight, boxHeight) ||
                other.boxHeight == boxHeight) &&
            (identical(other.shadowColor, shadowColor) ||
                other.shadowColor == shadowColor) &&
            (identical(other.animatedBoxColor, animatedBoxColor) ||
                other.animatedBoxColor == animatedBoxColor) &&
            (identical(other.blurRadius, blurRadius) ||
                other.blurRadius == blurRadius) &&
            (identical(other.spreadRadius, spreadRadius) ||
                other.spreadRadius == spreadRadius) &&
            (identical(other.borderRadius, borderRadius) ||
                other.borderRadius == borderRadius) &&
            const DeepCollectionEquality()
                .equals(other._gradientColors, _gradientColors) &&
            const DeepCollectionEquality()
                .equals(other.gradientState, gradientState) &&
            (identical(other.beginLinearGradient, beginLinearGradient) ||
                other.beginLinearGradient == beginLinearGradient) &&
            (identical(other.endLinearGradient, endLinearGradient) ||
                other.endLinearGradient == endLinearGradient) &&
            (identical(other.centerRadiusGradient, centerRadiusGradient) ||
                other.centerRadiusGradient == centerRadiusGradient));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      offsetDx,
      offsetDy,
      boxWidth,
      boxHeight,
      shadowColor,
      animatedBoxColor,
      blurRadius,
      spreadRadius,
      borderRadius,
      const DeepCollectionEquality().hash(_gradientColors),
      const DeepCollectionEquality().hash(gradientState),
      beginLinearGradient,
      endLinearGradient,
      centerRadiusGradient);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AnimatedBoxStateCopyWith<_$_AnimatedBoxState> get copyWith =>
      __$$_AnimatedBoxStateCopyWithImpl<_$_AnimatedBoxState>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AnimatedBoxStateToJson(
      this,
    );
  }
}

abstract class _AnimatedBoxState implements AnimatedBoxState {
  const factory _AnimatedBoxState(
      {final double offsetDx,
      final double offsetDy,
      final double boxWidth,
      final double boxHeight,
      final int shadowColor,
      final int animatedBoxColor,
      final double blurRadius,
      final double spreadRadius,
      final BorderRadiusModel borderRadius,
      final List<GradientColorModel> gradientColors,
      final GradientStateModel gradientState,
      final GradientDirectionModel beginLinearGradient,
      final GradientDirectionModel endLinearGradient,
      final GradientDirectionModel centerRadiusGradient}) = _$_AnimatedBoxState;

  factory _AnimatedBoxState.fromJson(Map<String, dynamic> json) =
      _$_AnimatedBoxState.fromJson;

  @override
  double get offsetDx;
  @override
  double get offsetDy;
  @override
  double get boxWidth;
  @override
  double get boxHeight;
  @override
  int get shadowColor;
  @override
  int get animatedBoxColor;
  @override
  double get blurRadius;
  @override
  double get spreadRadius;
  @override
  BorderRadiusModel get borderRadius;
  @override
  List<GradientColorModel> get gradientColors;
  @override
  GradientStateModel get gradientState;
  @override
  GradientDirectionModel get beginLinearGradient;
  @override
  GradientDirectionModel get endLinearGradient;
  @override
  GradientDirectionModel get centerRadiusGradient;
  @override
  @JsonKey(ignore: true)
  _$$_AnimatedBoxStateCopyWith<_$_AnimatedBoxState> get copyWith =>
      throw _privateConstructorUsedError;
}
